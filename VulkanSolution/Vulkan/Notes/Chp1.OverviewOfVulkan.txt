1. What is Vulkan
Vulkan is very verbose and somewhat fragile. For example, OpenGL does a lot of tasks instead of developer's state. However, Vulkan need to do state tracking, synchronization, and memory management by myself.

verbose -> I need to do an awful lot of work
fragile -> incorrect usage of the API might lead to graphical corruption or even program crash where I would have received a helpful error message.
What I can get -> more control over the device, a clean threading model, much higher performance.

2. Instances, Devices, and Queues

Application	- Instances	- Physical Devices	- Logical Devices	- Queues
					|					|								|							- ...
					|					|								|							- Queues
					|					|								|
					|					|								- Logical Devices	- ...
					|					|
					|					- Physical Devices	- ...
					|
					|													- ....
					|
					- Instances	......

Instance is a software consturct that logically separates the state of my application from other applications or libraries running within the context of my application

A physical device represents a single piece of hardware or a collection of hardware that is interconnected.

A logical device is created by the instance. It is a software construct around a physical device and represents a reservation of resources associated with a particular physical device.

3. The Vulkan Instance
The first Vulkan function I got is vkCreateInstance.
A declaration of this function is represented bellow
```
VkResult vkCreateInstance
(
	const VkInstanceCreateInfo* pCreateInfo, 
	const VkAllocationCallbacks* pAllocator, 
	VkInstance* pInstance
);
```
The book said this is general type of Vulkan function. pCreateInfo is a pointer to an instance of the VkInstanceCreateInfo structure that contains the parameters describing the new Vulkan instance.

```
typedef struct VkInstanceCreateInfo {
	VkStructureType					sType;
	const void*							pNext;
	VkInstanceCreateFlags		flags;
	const VkApplicationInfo*		pAllicationInfo;
	uint32_t								enabledLayerCount;
	const char* const*				ppEnabledLayerNames;
	uint32_t								enabledExtensionCount;
	const char* const*				ppEnabledExtensionNames;
} VkInstanceCreateInfo;
```
The first member variable 'sType' is used to pass parameters to the API.
Each structures and extensions has an assigned structure tag. Thanks to this tag, Vulkan is able to determine the type of the structure for validation purposes and for use in extensions.

The second member variable 'pNext' allows a linked list of structures to be passed to the function.

When we create a core instance, we are going to pass VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO in the sType field and simply set pnextT to nullptr;

The flags field of VkInstanceCreateInfo is reserved for future used and should be set to zero.
pApplicationInfo is an optional pointer to another structure describing my application. You can set this to nullptr, but a well-behaved application should fill this in with something useful. 

pApplicationInfo points to an instance of the VkApplicationInfo structure, the definition is described in bellow.

```
typedef struct VkApplicationInfo {
	VkStructureType sType;
	const void* pNext;
	const char* pApplicationName;
	uint32_t applicationVersion;
	const char* pEngineName;
	uint32_t engineVersion;
	uint32_t apiVersion;
}
```

sType should be set to VK-STRUCTURE_TYPE_APPLICATION_INFO, and we can leave pNext as nullptr.
pApplicationName is a pointer to a null-terminated string containing the name of your application, and applicationVersion is the version of the application.
applicationVersion allows tools and drivers to make decisions about how to treat your application without needing to guess which application is running. (I did not fully understand this sentence. This sentence is nearby figure2 in chapter1 in the book)

Finally, apiVersion contains the version of the Vulkan API that your application is expecting to run on. This should be set to the absolute minimum version of Vulkan that your application requires to run - not just to the version of the header that you happen to have installed.

let us back to the VkInstanceCreateInfo
enabledLayerCount & ppEnabledLayerNames fields. These are the count of the number of instance layers that you wish to enable and their names, respectively.
Layers are used to intercept the VulkanAPI and poride logging. profiling, debugging, or other additional features. If no layers are needed, simply set enabledLayerCount to zero and leave.
ppEnabledLayerNames as nullptr. 
Likewise, enabledExtensionCount is the count of the number of extensions you wish to enable, and ppEnableExtensionNames is a list of their names. 
Again, if we're not using any extensions, we can set these fields to zero and nullptr, respectively.

Finally, returning to the vkCreateInstance() function, the pAllocator parameter is a pointer to a host memory allocator that your application can supply in order to manage the host memory that the Vulkan system uses.
Setting this to nullptr causes the Vulkan system to use its own internal allocator, which is what we willl do here. Application-managed host memory will be covered in Chapter2, "Memory and Resources."

4. Vulkan Physical Devices.
Once we have an instance, we can use it to discover Vulkan-compatible devices installed in the system.
Physical devices are normally parts of the system - a graphics card, accelerator, DSP, or other component.A system has a fixed number of physical devices and a fixed set of capabilities.
A logical device is a software abstraction of a physical device, configured in a way that is specified by the application. The logical device is the one that your application will spend most of its time dealing with, but before we can create a logical device, we must discover the connected physical devices.
To do this, we call the vkEnumeratePhysicalDevices() function, the prototype of which is bellow

```
VkResult vkEnumeratePhysicalDevices
(
	VkInstance instance, 
	uint32_t* pPhysicalDeviceCount, 
	VkPhysicalDevice* pPhysicalDevices
);
```

The first parameter, instance, is the instance we created eariler. 
Next, the pPhysicalDeviceCount parameter is a pointer to an unsigned integer variable that is both an input and an output.
	- As an output, Vulkan writes the number of physical devices in the system into it. 
	- As an input, it should be preinitialized with the maximum number of devices your application can handle. 
The pPhysicalDevices parameter is a pointer to an array of the number of VkPhysicalDevice handles.

If you just want to know how many devices there are in the system, set pPhysicalDevices to nullptr, and Vulkan will ignore the initial value of pPhysicalDeviceCount. simply overwriting it with the number of supported devices.
After then call the same function again with dynamically adjust the size of VkPhysicalDevice array.

*** non-Vulkan topic : Originally, array allocation on std::shared_ptr is not available until C++17. However, C++20 is available. Thus, should check using c++ version is the latest version

Now, based on physical device we've gotten, we are going to query this to create logical device.

The first query I'll perform is 
```
void vkGetPhysicalDeviceProperties(
	VkPhysicalDevice physicalDevice,
	VkPhysicalDeviceProperties* pProperties
);
```

First paremter would get physical device what we've gotten by vkEnumeratePhysicalDevice.
Need to instantiate a type of VkPhysicalDeviceProperties to pass its address to second parameter.

The thing is though, VkPhysicalDeviceProperties structure is huge and contains a large number of fields describing the properties of the physical device.

The definition is
```
typedef struct VkPhysicalDeviceProperties
{
	uint32_t													apiVersion;
	uint32_t													driverVersion;
	uint32_t													vendorID;
	uint32_t													deviceID;
	VkPhysicalDeviceType							deviceType;
	char															deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
	uint8_5														pipelineCacheUUID[VK_UUID_SIZE];
	VkPhysicalDeviceLimits							limits;
	VkPhysicalDeviceSparseProperties		sparseProperties;
} VkPhysicalDeviceProperties;
```

The 'apiVersion' field contains the highest version of Vulkan supported by the device.
The 'driverVersion' field contains the version of the driver used to control the device. This is vendor-specific, so it does not make sense to compare driver sersions across the vendors.
The 'vendorID' and 'deviceID' fields identify the vendor and the device, and are usually PCI vendor and device identifiers.
The 'deviceName' field will contain a human-readable string naming the device.
The pipelineCacheUUID' field is used for pipeline caching, which we will cover in Chapter6, "Shaders and Pipelines."
The 'VkPhysicalDeviceLimits' and the 'VkPhysicalDeviceSparseProperties' contain the minimum and maximum limits for the physical device  and properties related to sparse textures. However, we are going to discuss deeply and separately in future.

In addtion to core feature, Vulkan has a number of optional features that may be supported by a physical device. but once enabled, that optional feature becomes a first-class citizen of the API just like any core feature.
To determine which features a physical deevice supports, call vkGetPhysicalDeviceFeatures(),

The prototype of which is
```
void vkGetPhysicalDeviceFeatures
(
	VkPhysicalDevice					physicalDevice,
	VkPhysicalDeviceFeatures*	pFeatures
);
```

Again, the VkPhysicalDeviceFeatures structure is very large and has a Boolean field for each optional feature supported by Vulkan. Its details might be cover later.

5. Physical Device Memory

Vulkan device is either hardware to the main host processor or software to access memory in specialized ways.
Device memory in Vulkan refers to memory that is accessible to the device and usable as a backing store for textures and other data.
Memory is classified into types. They has a set of properties, such as caching flags and coherency behavior between host and device.

To query the configuration of heaps and the memory types supported by the device, call
```
void vkGetPhysicalDeviceMemoryProperties(
	VkPhysicalDevice									physicalDevice,
	VkPhysicalDeviceMemoryProperties*		pMemoryProperties
);
```

The result is stored in VkPhysicalDeviceMemoryProperties structure, the address of which is passed in 'pMemoryProperties'.
The VkPhysicalDeviceMemoryProperties structrue contains the properties of both the device's heaps and its supported memory types.

The definition of this structure is
```
typedef struct VkPhysicalDeviceMemoryProperties
{
	uint32_t					memoryTypeCount;
	VkMemoryType		memoryTypes[VK_MAX_MEMORY_TYPES];
	uint32_t					memoryHeapCount;
	VkMemoryHeap		memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;
```

The 'memoryCount' field contains number of memory types. The maximum value which is logically correct is VK_MAX_MEMORY_TYPES, which is defined to be 32.
The 'memoryTypes' array VkMemoryType structures describing each of the memory types.

The definition is
```
typedef struc VkMemoryType
{
	VkMemoryPropertyFlags		propertyFlags;
	uint32_t								heapIndex;
} VKMemoryType
```

The 'flags' field describes the type of memory and is made up of a combination of the VkMemoryPropertyFlagBits flags. 

The meanings of the flags are as follows
```
1. VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT:
	It means that the memory is local to (that is, physically connected to) the device. 
	If this bit is not set, then the memory can be assumed to be local to the host.

2. VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT(????? I did not get it fully):
	It means that memory allocations made with the type can be mapped and read or written by the host. 
	If this bit is not set then memory of this type cannot be directly accessd by the host and is rather for exclusive use by the device.

3. VK_MEMORY_PROPERTY_HOST_COHERENT_BIT:
	It means that when this type of memory is concurrently accessed by both the host and device, those accesses will be coherent between the two clients.(?????????? two clients???? who are they??)
	If this bit is not set then the device or host may not see the results of writes performed by each until caches are explicitly flushed.

4. VK_MEMORY_PEOPERTY_HOST_CACHED_BIT:
	It means that data in this type of memory is cached by the host.
	Read accesses to this type of memory are typically faster than they would be if this bit were not set.
	However, access by the device may have slightly higher latency, especially if the memory is also coherent.

5. VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT:
	It means that memory allocated with this type does not necessarily consume space from the associated heap immediately and that a driver might defer physical memory allocation until the memory object is used to back a resource.
```

Each memory type reports the heap from which is consumes space in the 'heapIndex' is an index into the 'memoryHeaps' array.
Each elements of the 'memoryHeaps' array describes one of the device's memory heaps.

the definition of this structure is
```
typedef struct VkMemoryHeap
{
	VkDeviceSize					size;
	VkMemoryHeapFlags		flags;
} VkMemoryHeap;
```
This is simple structure which contains only the size, in bytes, of the heap and some flags describing the heap.
However, in Vulkan 1.0, the only defined flag is VK_MEMORY_HEAP_DEIVCE_LOCAL_BIT. (which means that It might be different when Vulkan is updated.)
If this bit is set, then the heap is local to the device. This corresponds to the similarly named flag describing memory types. 

6. Device Queues

Vulkan devices execute work that is submitted to queues.
A queue family is a group of queues that have identical capabilities but are able to run in parallel.
The number of queue families, the capabilities of each family, and the number of queues belonging to each family are all properties of the physical device.
To query the device for its queue families, call vkGetPhysicalDeviceQueueFamilyProperties().

The prototype of which is
```
void vkGetPhysicalDeviceQueueFamilyProperties(
	VkPhysicalDevice					physicalDevice,
	uint32_t*									pQueueFamilyPropertyCount,
	VkQueueFamilyProperties*		pQueueFamilyProperties
);
```

It works somewhat like vkEnumeratePhysicalDevices() in that it is expected that you call it twice.
First call with nullptr, second call with dynamically allocated pointer. Make sure that pQueueFamilyPropertyCount should be valid pointer.

The definition of VkQueueFamily Properties is
```
typedef struct VkQueueFamilyProperties
{
	VkQueueFlags			queueFlags;
	uint32_t					queueCount;
	uint32_t					timestampValidBits;
	VkExtent3D				minImageTransferGranularity;
} VkQueueFamilyProperties;
```

The 'queueFlags' rield describes the overall capabilities of the queue.
This field is made up of a combination of the VkQueueFlagBits bits, the meanings of which are as follows
```
1. VK_QUEUE_GRAPHICS_BIT:
	If it is set, then queues in this family support graphics operations such as drawing points, lines, and triangles.

2. VK_QUEUE_COMPUTE_BIT:
	If it is set, then queues in this family support compute operations such as dispatching compute shaders.

3. VK_QUEUE_TRANSFER_BIT:
	If it is set, then queues in this family support transfer operations such as copying buffer and image contents.

4. VK_QUEUE_SPARSE_BINDING_BIT:
	If it is set, then queues in this family support memory binding operations used to update sparse resources. (I did not fully understand this bit)
```

The 'queueCount' field might be set to 1, or it could be substantially higher if the device supports multiple queues with the same basic functionality.

The 'timeStampValidBits' field indicates how many bits are valid when timestamps are taken from the queue.
If this value is zero, then the queue does not support timestamps. 
If it's nonzero, then It's guaranteed to be at least 36 bits. Furthermore, if the 'timestampComputeAndGraphics' field of the device's VkPhysicalDeviceLimits structure is VK_TRUE, then all queues supporting either VK_QUEU_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT are guaranteed to support timestamps with at least 36 bits of resolution. (I did not understand though)
In this case, there's no need to check each queue individually.

The 'minImageTimestampGranularity' field specifies the units with which the queue supports image transfers (if at all).

Note that it might be the case that a device reports more than one queue family with apparently identical properties. 
Queues within a family are essentially identical, Queues in different families may have different internal capabilities that cannot be expressed easily in the Vulkan API.
For this reason, an implementation might choose to report similar queues as members of different families.
This places additional restrictions on how resources are shared between those queues, which might allow the implementation to accommodate those differences.

7. Creating a Logical Device

The logical device represents the device in an initialized state.
During creation of the logical device, you get to opt in to optional features, turn on extensions you need, and so on.
Creating the logical device is performed by calling vkCreateDevice(),

the prototype of which is
```
VkResult vkCreateDevice(
	VkPhysicalDevice						physicalDevice,
	const VkDeviceCreateInfo*			pCreateInfo,
	const VkAllocationCallbacks*		pAllocator,
	VkDevice*									pDevice
);
```

The information about the new logical device is passed in an instance of the VkDeviceCreateInfo structure.

The definition of which is
```
typedef struct VkDeviceCreateInfo
{
	VkStructureType									sType;
	const void*											pNext;
	VkDeviceCreateFlags							flags;
	uint32_t												queueCreateInfoCount;
	const VkDeviceQueueCreateInfo*		pQueueCreateInfos;
	uint32_t												enabledLayerCount;
	const char* const*								ppEnabledLayerNames;
	uint32_t												enabledExtensionCount;
	const char* const*								ppEnabledExtensionNames;
	const VkPhysicalDeviceFeatures*		pEnabledFeatures;
} VkDeviceCreateInfo;
```

The 'sType' field of the VkDeviceCreateInfo structure should be set to VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO.
As usual unless you are using extensions, 'pNext' should be set to nullptr.
In the current version of Vulkan, no bits are defined for the 'flags' field of the structure, so set this to zero too.

'pQueueCreateInfos' is a pointer to an array of one or more VkDeviceQueueCreateInfo structures, each of which allows the specification of one or more queues.
The number of structures in the array is given in 'queueCreateInfoCount'

The definition of VkDeviceQueueCreateInfo is
```
typedef struct VkDeviceQueueCreateInfo
{
	VkStructureType							sType;
	const void*									pNext;
	VkDeviceQueueCreateFlags		flags;
	uint32_t										queueFamilyIndex;
	uint32_t										queueCount;
	const float*									pQueuePriorities;
} VkDeviceQueueCreateInfo;
```

The 'sType'f field for VkDeviceQueueCreateInfo is VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO.
There are currently no flags defined for use in the 'flags' field, so it should be set to zero.

The 'queueFamilyIndex' field specifies the family of the queues you want to create. (????????) 
This is an index into the array of queue families returned from vkGetPhysicalDeviceQueueFamilyProperties().
To create queues in this family, set 'queueCount' to the number of queues you want to use.
Of course, the device must support at least this many queues in the family you choose.

The 'pQueuePriorities' field is an optional pointer to an array of floating pointer values representing the relative priority of work submitted to each of the queues.
These numbers are normalized numbers in the range of 0.0 to 1.0.
Queues with higher priority may be allocated more processing resources or scheduled more aggressively than queues with lower priority.
Setting 'pQueuePriorities' to nullptr has the effect of leaving the queues at the same, default priority.

(????????????????????????)
The requested queues are sorted in order of priority and then assigned device-dependent relative priorities
The number of descrete priorities that a queue may take on is a device-specific parameter.
You can determine this by checking the 'discreteQueuePriorities' field of the 'VkPhysicalDeviceLimits' structure returned from a call ot vkGetPhysicalDeviceProperties().
For example, if a device supports only low- and high-priority workloads, this field will be 2. 
All devices support at least two discrete priority levels.
Regardless of the value of 'discreteQueuePriorities', the relative priorities of the queue are still expressed as floating-point values.

Returning to the 'VkDeviceCreateInfo' structure, the 'enabledLayerCount', 'EnabledLayerNames',  'enabledExtensionCount', and 'ppEnabledExtensionNames' fields are for enabling layers and extensions.
We will cover both of these topics later in this chapter. For now, we'll set both 'enabledLayerCount' and 'enabledExtensionCount' to zero and both 'ppEnabledLayerNames' and 'ppEnablesExtensionNames' to nullptr.

The final field, 'pEnabledFeatures', is a pointer to an instance of the VkPhysicalDeviceFeatures structure.
If you do not want to do, you can simply set this to nullptr.
However, Vulkan in this form is relatively limited, and much of its interesting functionality will be disabled.
In order to use, simeply pass a 'VkPhysicalDeviceFeatures' structure which I've gotten in vkGetPhysicalDeviceFeatures().

Simply enabling every supported feature, however, may come with some performance impact. 
For some features, a Vulkan implementation may need to allocate extra memory,track additional state, configure hardware slightly differently, or perform some other operation that otherwise costs your application.
It's not a good idea to enable features that won't be used.
In an optimized application, you should query the supported features from the device; then, from the supported features, enable the specific features that your application requires.

8. Object Types and Function Conventions
Vulkan can categorize all objects into two types: dispatchable objects and nondispatchable objects.
They are not relevant to applications and affects only how the API is structured and how system-level components such as the Vulkan loader and layers interoperate with those objects.

Dispatchable objects are objects that internally contain a dispatch table.
This is the table of functions used by various components to determine which parts of code to execute when your application makes calls to Vulkan.
These types of objects are generally heavier-weight constructs and currently consist of the instance, physical device, logical device, command buffer, and queue.
All other objects are considered nondispatchable.

The first argument to any Vulkan function is always a dispatchable object.
The only exceptions to this rule are the functions related to creating and initializing the instance.

9. Managing Memory
Vulkan provides two types of memory: 'host' memory & 'device' memory.
Objects created by the Vulkan API need some of host memory. This is where the Vulkan implementation will store the state of the object and any data it needs to implement the Vulkan API.
Resource objects such as buffers and images require some amount of device memory. This is the memory where the data stored in the resource is kept.

You are able to manage host memory for the Vulkan implementation and device memory.
To do this, I will need to create a device memory management subsystem.

'You', the application developer, know exactly how your application will behave.
You can partition resources into long-lived and transient groups.
You can bucket resources that will be used together into a small number of pooled allocations.
You are in the best position to decide the allocation strategies used by your application.

It is important to keep the number of allocation objects to a minimum because each "live" memory allocation places some cost on the system.

10. Multithreading in Vulkan.

Vulkan generally assumes that the application will ensure that no two threads are mutating the same object at the same time.
This is known as 'external synchronization'.
The vast majority of Vulkan commands in the performance-critical portions of Vulkan (such as building command buffers) provide no synchronization at all.

The Vulkan includes a number of higher-level features that are designed specifically to allow threads to perform work without blocking one another, which means we do not need to do mutex or use other synchronization primitives internally to protect data structures.
These include the following:
```
1.	Host memory allocations can be handled through a host memory allocation structure passed to object creation functions.
	By using an allocator per thread, the data structures in that allocator do not need to be protected. Host memory allocators are covered in Chapter 2, "Memory and Resources."

2.	Command buffers are allocated from pools, and access to the pool is externally synchronized.
	If an appliocation uses a separate command pool per thread, command buffers can be allocated from those pools without block against one another.
	Command buffers and pools are covered in Chapter 3, "Queues and Commands."

3.	Descriptors are allocated in sets from descriptor pools.
	Descriptors are the representation of resources as used by shaders running on the device.
	They are covered in detail in Chapter 6, "Shaders and Pipelines."
	If a separate pool is used for each thread, then descriptor sets can be allocated from those pools without the threads blocking one another.

4.	Second-level command buffers allow the contents of a large renderpass (which must be contained in a single command buffer) to be generated in parallel and then grouped as they're called from the primary command buffer.
	Secondary command buffers are covered in detail in Chapter 13, "Multipass Rendering."
```

When you are building a very simple, single-threaded application, the requirement to create pools from which to allocate objects may seem like a lot of unnecessary indirection.
However, as applications scale in number of threads, these objects are indispensible to achieving high performance.

11. ENHANCING VULKAN
Layers - which modify or enhance existing behavior
Extensions - which add new functionality to Vulkan

12. Layers
Layers are features of Vulkan that allow its behavior to be modified.
Layers generally intercept all or part of Vulkan and add functionality such as logging, tracing, providing diagnostics, profiling, and so on.
A layer can be added at the instance level, and possibly every device created by it.
Alternatively, the layer can be added at the device level, in which case it affects only the device for which it is enabled.

To discover the layers available to an instance on a system, call vkEnuermateInstanceLayerProperties(),
the prototype of which is
```
VkResult vkEnumerateInstanceLayerProperties(
	uint32_t*						pPropertyCount;
	VkLayerProperties*		pProperties
);
```

If 'pProperties' is nullptr, then 'pPropertyCount' should point to a variable that will be overwritten with the count of the number of layers available to Vulkan.
If it is not nullptr, then it should point to an array of VkLayerProperties structures that will be filled with information about the layers registered with the system.

Each element of the pProperties array is an instance of the VkLayerProperties structure,
the definition of which is
```
typedef struct VkLayerProperties
{
	char				layerName[VK_MAX_EXTENSION_NAME_SIZE];
	uint32_t		specVersion;
	uint32_t		implementationVersion;
	char				description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;
```

Each layer has a formal name that is stored in the 'layerName' member of the VkLayerProperties structure.
As the specification for each layer might be improved, clarified, or appended to over time, the version of the layer implementation is reported in 'specVersion'
The 'implementationVersion' field stored how many implementations improved as specifications are improved over time.
The purpose of 'description' field is for logging or display in a user interface, and it is for informational purposes only.

When we want to inject layers to device level, call vkEnumerateDeviceLayerProperties(),
the prototype of which is
```
VkResult vkEnumerateDeviceLayerProperties(
	VkPhysicalDevice			physicalDevice,
	uint32_t*							pPropertyCount,
	VkLayerProperties*			pProperties
);
```

The way how to use it is technically same as instance level.

To enable a layer at the instance level, include its name in the 'ppEnabledLayerNames' field of the VkInstanceCreateInfo structure used to create the instance.
Likewise, to enable a layer when creating a logical device corresponding to a physical device in the system, include the layer name in the 'ppEnabledLayerNames' member of the VkDeviceCreateInfo used to create the device.

Several layers are included in the official SDK, most of which are related to debugging, parameter validation, and loggig.
These include the following:
```
1. VK_LAYER_LUNARG_api_dump
	It prints Vulkan calls and their parameters and values to the console.

2. VK_LAYER_LUNARG_core_validation
	It performs validation on parameters and state used in descriptor sets, pipeline state, and dynamic state; validates the interfaces between SPIR_V modules and the graphics pipeline; and tracks and validates usage of GPU memory used to back objects.

3. VK_LAYER_LUNARG_device_limits
	It ensures that values passed to Vulkan commands as arguments or data structure members fall within the device's supported feature set limits.

4. VK_LAYER_LUNARG_image
	It validates that image usage is consistent with supported formats.

5. VK_LAYER_LUNARG_object_tracker
	It performs tracking on Vulkan objects, attemting to catch leaks, use-after-free errors, ans other invalid object usage.

6. VK_LAYER_LUNARG_parameter_validation
	It confirms that all parameter values psassed to Vulkan functions are valid.

7. VK_LAYER_LUNARG_swapchain
	It performs validation on functionality provided by the WSI(Window System Integration) extensions described in Chapter 5, "Presentation"

8. VK_LAYER_GOOGLE_threading
	It ensures valid usage of Vulkan commands with respect to threading, ensuring that no two threads access the same object at the same time when they should not.

9. VK_LAYER_GOOGLE_unique_objects
	It ensures that every object will have a unique handle for easier tracking by the application, avoiding cases where an implementation might de-duplicate handles that represent objects with the same parameters.
```

In addition to this, a large number of separate layers are grouped into a larger, single layer called VK_LAYER_LUNARG_standard_validation, making it easy to turn on.
The book's application framework enables this layer when built in debug mode, leaving all layers disabled when built in release mode.