All resources upon which Vulkan operates must be backed by device memory, and it is the application's responsibility to manage this memory.
Further, memory is used to store data structures on the host.

1. Host Memory Management
Whenever Vulkan creates new objects, it might need memory to store data related to the,.
For this, it uses 'host memory', which is regular memory accessible to the CPU that might be returned from a call to malloc or new, for example.
Vulkan expects allocations to be aligned correctly for some high-performance CPU instructions.

Because of these requirements, Vulkan implementations will use advanced allocators to satisfy them but sometimes it also provides the opportunity for us to replace the allocators by ourselves.

Can you remember 'pAllocator' parameter in vkCreateInstance() function?

```
VkResult vkCreateInstance(
	const VkIsntanceCreateInfo*			pCreateInfo,
	const VkAllocationCallbacks*			pAllocator,
	VkInstance*										pInstance
);
```
The 'pAllocator' parameter is a pointer to a VkAllocationCallbacks structure which what we've been setting to nullptr.
The VkAllocationCallbacks structure encapsulates a custom memory allocator that we can provide.
The definition of the structure is
```
typedef struct VkAllocationCallbacks
{
	void*														pUserData;
	PFN_vkAllocationFunction						pfnAllocation;
	PFN_vkReallocationFunction					pfnReallocation;
	PFN_vkFreeFunction								pfnFree;
	PFN_vkInternalAllocationNotification		pfnInternalAllocation;
	PFN_vkInternalFreeNotification				pfnInternalFree;
} VkAllocationCallback;
```

The 'pUserData' is for your application's use.
It can point anywhere; Vulkan will not dereference it.
You can put anything in there, so long as it fits into a pointer-size blob.
The only thing that Vulkan will do with 'pUserData' is pass it back to the callback functions to which the remaining members of VkAllocationCallbacks point.

'pfnAllocation', 'pfnReallocation', and 'pfnFree' are used for normal, object-level memory management.
They are defined as pointer to functions that match the following declarations.
```
void* VKAPI_CALL Allocation(
	void*										pUserData,
	size_t										size,
	size_t										alignment,
	VkSystemAllocationScope		allocationScope
);

void* VKAPI_CALL Reallocation(
	void*										pUserData,
	void*										pOriginal,
	size_t										size,
	size_t										alignment,
	VkSystemAllocationScope		allocationScope
);

void VKAPI_CALL Free(
	void*										pUserData,
	void*										pMemory
);
```

If your application uses data structures to manage memory, this is a good place to put their addresses, put the class's this pointer in 'pUserData'.

The 'Allocation' function is responsible for making new allocations.
The 'size' parameter give the size of the allocation, in bytes.
The 'alignment' parameter gives the required alighment of the allocation, also in bytes.
This is an often-overlooked parameter.
It is very tempting to simply hook this function up to a naive allocator such as malloc.
If you do this, you will find that it works for a while but that certain functiosn might mysteriously crash later.
If you provide your own allocator, it must honor the 'alignment' parameter.

The final parameter, 'allocationScope', tells your application what the scope, or life-time, of the allocation is going to be.
It is one of the VkSystemAllocationScope values, which have the following meanings:
```
1. VK_SYSTEM_ALLOCATION_SCOPE_COMMAND
	It means that the allocation will be live only for the duration of the command that provoked the allocation.
	Vulkan will likely use this for very short-lived temporary allocations, as it works on a single command.

2. VK_SYSTEM_ALLOCATION_SCOPE_OBJECT
	It means that the allocation is directly associated with a particular Vulkan object. 
	This allocation will live at least until the object is destroyed. 
	This type of allocation will only ever be made as part of executing a creation command (one beginning with vkCreate).

3. VK_SYSTEM_ALLOCATION_SCOPE_CACHE
	It means that the allocation is associated with some form of internal cache or a VkPipelineCache object. (I did not get it perfectly though...)

4. VK_SYSTEM_ALLOCATION_SCOPE_DEVICE
	It means that the allocation is scoped to the device.
	This allocation is made when the Vulkan implementation needs memory associated with the device that is not tied to a single object.
	For example, if the implementation allocates objects in blocks, this type of allocation might be made in response to a request to create a new object, 
		but becasue many objects might live in the same block, the allocation cannot be tied directly to any specific object.
	(I did not fully understand, does it technically same with VK_SYSTEM_ALLOCATION_SCOPE_OBJECT but not tied in a specific object??? What does block means precisely?)

5. VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE
	It means that the allocation is scoped to the instance, This is similar to VK_SYSTEM_ALLOCATION_SCOPE_DEVICE.
	This type of allocation is typically made by layers or during early parts of Vulkan startup, such as by vkCreateInstance() and vkEnumeratePhysicalDevices().
	(The part which I does not make sence is allocation is happend in vkEnumeratePhysicalDevices()??? We did not free physcal devices)
```

The 'pfnInternalAllocation' and 'pfInternalFree' function pointers point to alternate allocator functions that are used when Vulkan makes memory allocations using its own allocators.(??? What?)
These callbacks have the same signitures as 'pfnAllocation' and 'pfnFree', except that 'pfnInternalAllocation' does not return a vlaue and 'pfnInternalFree' should not actually free the memory.
These functions are used only for notification so that your application can keep track of how much memory Vulkan is using. 
The prototypes of these functions should be
```
void VKAPI_CALL InternalAllocationNotofication(
	void*										pUserData,
	size_t										size,
	VkInternalAllocationType			allocationType,
	VkSystemAllocationScope		allocationScope
);

void VKAPI_CALL InternalFreeNotification(
	void*										pUserData,
	size_t										size,
	VkInternalAllocationType			allocationType,
	VkSystemAllocationScope		allocationScope
);
```

There's not much you can do with the information provided through 'pfnInternalAllocation' and 'pfnInternalFree' besides log it and keep track of the total memory usage made by the application.
Specifying these function pointers is optional, but if you supply one, you must supply both.
If you do not want to use them, set them both to nullptr.

Bellow codes show an example of how to declare a C++ class that can be used as an allocator that maps the Vulkan allocation callback functions.
Because the callback functions used by Vulkan are naked C function pointers, the callback functions themselves are declared as static member functions of the class,  whereas the actual implementations of those functions are declared as regular nonstatic member functions.

```
class allocator
{
public:
	// Operator that allows an instance of this class to be used as a
	// VkAllocationCallbacks structure
	inline operator VkAllocationCallbacks() const
	{
		VkAllocationCallbacks result;


		result.pUserData = (void*)this;
		result.pfnAllocation = &Allocation;
		result.pfnReallocation = &Reallocation;
		result.pfnFree = &Free;
		result.pfnInternalAllocation = nullptr;
		result.pfnInternalFree = nullptr;

		return result;
	}

private:
	// Declare the allocator callbacks as static member functions.
	static void* VKAPI_CALL Allocation(void* pUserData, size_t size, size_t alignment, VkSystemAllocationScope allocationScope);
	static void* VKAPI_CALL Reaclloation(void* pUserData, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope);
	static void VKAPI_CALL Free(void* pUserData, void* pMemory);

	// Now declare the nonstatic member functions that will actually perform
	// the allocations
	void* Allocation(size_t size, size_t alignment, VkSystemAllocationScope allocationScope);
	void* Reallocation(void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope);
	void Free(void* pMemory);
};
```

An example implementation of this class is shown in below codes.
It maps the Vulkan allocation functions to the POSIX aligned_malloc functions. 
Note that this allocator is almost certainly not better than what most Vulkan implementations use internally and serves only as an example of how to hook the callback functions up to your own code.

```
void* allocator::Allocation(size_t size, size_t alignment, VkSystemAllocationScope allocationScope)
{
	return aligned_mallloc(size, alignment);
}

void* VKAPI_CALL allocator::Allocation(void* pUserData, size_t size, size_t alignment, VkSystemAllocationScope allocationScope)
{
	return static_cast<allocator*>(pUserData)->Allocation(size, alignment, allocationScope);
}

void* allocator::Reallocation(void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope)
{
	return aligned_realloc(pOriginal, size, alignment);
}

void* VKAPI_CALL allocator::Reallocation(void* pUserData, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope)
{
	return static_cast<allocator*>(pUserData)->Reallocation(pOriginal, size, alignment, allocationScope);
}

void allocator::Free(void* pMemory)
{
	aligned_free(pMemory);
}

void VKAPI_CALL allocator::Free(void* pUserData, void* pMemory)
{
	return static_cast<allocator*>(pUserData, pMemory);
}
```

2. Resources
Vulkan operates on data.
Data is stored in resources, and resources are backed by memory.
There are two fundamental types of resources in Vulkan:
1. buffers
2. Images.
A buffer is a simple, linear chunk of data that can be used for almost anything - data structures, raw arrays, and even image data, should you choose to use them that way.
Images, on the other hand, are structured and have type and format information, can be multidimensional, form arrays of their own, and support advanced oeprations for reading and writing data from and to them.

Both types of resources are constructed in two steps: first the resource itself is created, and then the resource needs to be backed by memory.
The reason for this is to allow the application to manage memory itself.
For example, an applications that uses a small number of very large resources and keeps them around for a long time might use one strategy in its memory allocator, while another application that continually creates and destroys small resources might implement another.

This section looks at buffer creation first and then moves on to discuss images.

3. Buffers
Buffers are the simplest type of resource but have a wide variety of uses in Vulkan.
They are used to store linear structured or unstructured data, which can have a format or be raw bytes in memory.
The various uses for buffer objects will be discussed as we introduce those topics.
To create a new buffer object, call vkCreateBuffer(),
the prototype of which is
```
VkResult vkCreateBuffer(
	VkDevice											device,
	const VkBufferCreateInfo*				pCreateInfo,
	const VkAllocationCallbacks*			pAllocator,
	VkBuffer*											pBuffer
);
```

Here, the 'pCreateInfo' parameter is a pointer to an instance of the VkBufferCreateInfo structure, the definition of which is

```
typedef struct VkBufferCreateInfo
{
	VkStructureType				sType;
	const void*						pNext;
	VkBufferCreateFlags		flags;
	VkDeviceSize					size;
	VkBufferUsageFlags		usage;
	VkSharingMode				sharingMode;
	uint32_t							queueFamilyIndexCount;
	const uint32_t*					pQueueFamilyIndices;
} VkBufferCreateInfo;
```

The 'sType' for VkBufferCreateInfo should be set to VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
and the 'pNext' member should be set to nullptr unless you're using an extension.
The 'flags' field of the structure gives Vulkan some information about the properties of the new buffer.
In the current version of Vulkan, the only bits defined for use in the 'flags' field are related to 'sparse buffers', which we will cover later in this chapter.
For now, 'flags' can be set to zero.

The 'size' field of VkBufferCreateInfo specifies the size of the buffer, in bytes.
The 'usage' field tells Vulkan how you're going to use the buffer and is a bitfield made up of a combination of members of the VkBufferUsageFlagBits enumaration.
On some architectures, the intended usage of the buffer can have an effect on how it's created.
The currently defined bits along with the sections where we'll discuss them are as follows:
```
1.	VK_BUFFER_USAGE_TRANSFER_SRC_BIT &
	VK_BUFFER_USAGE_TRANSFER_DST_BIT
	They mean that the buffer can be used to back a uniform or storage texel buffer, respectively.
	Texel buffers are formatted arrays of texels that can be used as the source or destination (in the case of storage buffers) of reads and writes by shaders running on the device.
	Texel buffers are covered in Chapter 6, "Shaders and Pipelines"

2. VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT &
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
	They mean that the buffer can be used to back a uniform or storage texel buffer, respectively.
	Texel buffers are formatted arrays of texels that can be used as the source or destination (in the case of storage buffers) of reads and writes by shaders running on the device.
	Texel buffers are covered in Chapter 6, "Shaders and Pipelines".

3. VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT &
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
	They mean that the buffer can be used to back uniform or storage buffers, respectively.
	As opposed to texel buffers, regular uniform and storage buffers have no format associated with them and can therefore be used to store arbitrary data and data structures.
	They are covered in Chpater 6, "Shaders and Pipelines".

4. VK_BUFFER_USAGE_INDEX_BUFFER_BIT &
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
	They mean that the buffer can be used to store index or vertex data, respectively, used in drawing commands.
	You'll learn more about drawing commands, including indexed drawing commands, in Chpater 8, "Drawing".

5. VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT
	It means that the buffer can be used to store parameters used in indirect dispatch and drawing commands, which are commands that take their parameters directly from buffers rather than from your program.
	These are covered in Chapter 6, "Shaders and Pipelines," and Chapter 8, "Drawing".
```

The 'sharingMode' field of VkBufferCreateInfo indicates how the buffer will be used on the multiple command queues supported by the device.
Because Vulkan can execute many operations in parallel, some implementations need to know whether the buffer will essentially be used by a single command at a time or potentially by many.
```
Setting 'sharingMode' to VK_SHARING_MODE_EXCLUSIVE:
	It says that the buffer will only be used on a single queue.
	
Setting sharingMode to VK_SHARING_MODE_CONCURRENT: 
	It indicates that you plan to use the buffer on multiple queues at the same time.
	Using this mode might result in lower performance on some systems, so unless you need this, set sharingMode to 'VK_SHARING_MODE_EXCLUSIVE'.
```

If you do set 'sharingMode' to VK_SHARING_MODE_CONCURRENT, you need to tell Vulkan which queues you're going to use the buffer on.
This is done using the 'pQueueFamilyIndices' member of VkBufferCreateInfo, which is a pointer to an array of queue families that the resource will be used on.
'queueFamilyIndexCount' contains the length of this array-the number of queue families that the buffer will be used with.
When 'sharingMode' is set to VK_SHARING_MODE_EXCLUSIVE, 'queueFamilyCount' and 'pQueueFamilies' are both ignored.

The bellow codes demonstrate how to create a buffer object that is 1MiB in size, usable as the source or destination of transfer operations, and used on only one queue family at a time.

```
static const VkBufferCreateInfo bufferCreateInfo = 
{
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
	nullptr,
	0,
	1024 * 1024,
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
	VK_SHARING_MODE_EXCLUSIVE,
	0,
	nullptr
}

VkBuffer buffer = VK_NULL_HANDLE;
vkCreateBuffer(device, &bufferCreateInfo, &buffer);
```

After the code has run, a new VkBuffer handle is created and placed in the 'buffer' variable. 
The buffer is not yet fully usable because it first needs to be backed with memory.
This operation is covered in "Device Memory Management" later in this chapter.

4. Formats and Support
While buffers are relatively simple resources and do not have any notion of the format of the data they contain, images and buffer view(which we will introduce shortly) do include information about their content
Part of that information describes the format of the data in the resourc.
Some formats have special requirements or restrictions on their use in certain parts of their pipeline.
For example, some formats might be readable but not writable, which is common with compressed formats.

In order to determine the properties and level of support for various formats, you can calll vkGetPhysicalDeviceFormatProperties(),
the prototype of which is
```
void vkGetPhysicalDeviceFormatProperties
(
	VkPhysicalDevice			physicalDevice,
	VkFormat							format,
	VkFormatProperties*		pFormatProperties
);
```

the physical device handle is specified in 'physicalDevice'.
If your application absolutely required support for a particular format or set of formats, you could check for support befroe even creatin g the logical device and reject particular physical devices from consideration early in application startup, for example.
The format for which to check support is specified in 'format'. 
If the device recognizes the format, it will write its level of support into the instance of the VkFormatProperties structure pointed to by 'pFormatProperties'.
The definition of which is
```
typedef struct VkFormatProperties
{
	VkFormatFeatureFlags		linearTilingFeatures;
	VkFormatFeatureFlags		optimalTilingFeatures;
	VkFormatFeatureFlags		bufferFeatures;
} VkFormatProperties;
```

All three fields in the structure are bitfields made up from members of the VkFormatFeatureFlagBits enumeration.
An image can be in one of two parimary tiling modes:
```
1. Linear
	It is laid out linearly in memory, first by row, then by column, and so on.

2. Optimal
	It is laid out in highly optimized partterns that make efficient use of the device's memory subsystem.
```

The 'linearTilingFeatures' field indicates the level of support for a format in images in linear tiling.
The 'optimalTilingFeatures' field indicates the level of support for a format in images in optimal tiling.
The 'bufferFeatures' field indicates the level of support for the format when used in a buffer.

The various bits that might be included in these fields are defined as follows:
```
1. VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT
	The format may be used in read-only images that will be sampled by shared.

2. VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
	Filter modes that include linear filtering may be used when this format is used for a sampled image.

3. VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT
	The format may be used in read-write images that will be read and written by shaders.

4. VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT
	The format may be used in read-write images that also support atomic operations performed by shaders.

5. VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT
	The format may be used in read-write texel buffer that will be read from by shaders.

6. VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT
	The format may be used in read-write texel buffers that may be read from and written to by shaders.

7. VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
	The format may be used in read-write texel buffers that also support atomic operations performed by shaders.

8. VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT
	The format may be used as the source of vertex data by the vertex-assembly stage of the graphics pipeline.

9. VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
	The format may be used as a color attachment in the color-blend stage of the graphics pipeline.

10. VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT
	Images with this format may be used as color attachments when ble.

11. VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
	The format may be used as a depth, stencil, or depth-stencil attachment.

12. VK_FORMAT_FEATURE_BLIT_SRC_BIT
	The format may be used as the source of data in an image copy oepration.

13. VK_FORMAT_FEATURE_BLIT_DST_BIT
	The format may be used as the destination of an image copy operation.
```

Many formats will have a number format support bits turned on.
A complete list of the mandatory formats is contained in the Vulkan specification.
If a format is on the madatory list, then it's not strictly necessary to test for support.
However, for completeness, implementations are expected to accurately report capabilities for all supported formats, even mandatory ones. (????)

The vkGetPhysicalDeviceFormatProperties() function really returnes only a coarse set of flags indicating whether a format may be used at all under particular scenarios.
For images expecially, there may be more complex interactions between a specific format and its effect on the level of support within an image.
Therefore, to retrieve even more information about the support for a format when used in images, you can call vkGetPhysicalDeviceImageFormatProperties(),
the prototype of which is
```
VkResult vkGetPhysicalDeviceImageFormatProperties(
	VkPhysicalDevice					physicalDevice,
	VkFormat									format,
	VkImageType							type,
	VkImageTiling							tiling,
	VkImageUsageFlags				usage,
	VkImageCreateFlags				flags,
	VkImageFormatProperties*		pImageFormatProperties
);
```

The type of image that you want to ask about is specified in 'type'.
This should be one of the image types:
```
1. VK_IMAGE_TYPE_1D
2. VK_IMAGE_TYPE_2D
3. VK_IMAGE_TYPE_3D
```
Different image types might have different restrictions or enhancements.
The tiling mode for the image is specified in 'tiling' and can be either VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, indicating linear or optimal tiling, respectively.

The intended use for the image is specified in the 'usage' parameter.
This is a bitfield indicating how the image is to be used.
The various uses for an image are discussed later in this chapter.
The 'flags' field should be set to the same value that will be used when creating the image that will use the format. (???)

If the format is recognized and supported by the Vulkan Implementation, then it will wrtie information about the level of support into the VkImageFormatProperties structure pointed to by 'pImageFormatProperties'.
The definition of VkImageFormatProperties is
```
typedef struct VkImageFormatProperties
{
	VkExtent3D							maxExtent;
	uint32_t								maxMipLevels;
	uint32_t								maxArrayLayers;
	VkSampleCountFlags			sampleCounts;
	VkDeviceSize						maxResourceSize;
} VkImageFormatProperties;
```

The 'extent' member of VkImageFormatProperties reports the maximum size of an image that can be created with the specified format.
For example, formats with fewer bits per pixel may support creating larger images than those with wider pixels.
'extent' is an instance of the VkExtent3D structure, the definition of which is (????????)
```
typedef struct VkExtent3D
{
	uint32_t		width;
	uint32_t		height;
	uint32_t		depth;
} VkExtent3D;
```

The 'maxMipLevels' field reports the maximum number of mipmap levels supported for an image of the requested format along with the other parameters passed to vkGetPhysicalDeviceImageFormatProperties().
In most cases, 'maxMipLevels' will either report log2(max(extent.x, extent.y, extent.z)) for the image when mipmaps are supported or 1 when mipmaps are not supported.

The 'maxArrayLayers' field reports the maximum number of array layers supported for the image.
Again, this is likely to be a fairly high number if arrays are supported or 1 if arrays are not supported.

If the image format supports mjultisampling, then the supported sample counts are reported through the 'sampleCounts' field.
This is a bitfield containing one bit for each supported sample count.
If bit n is set, then images with 2^n samples are supported in this format.
If the format is supported at all, at least one bit of this field will be set.
It is very unlikely that you will ever see a format that supportes multisampling but does not support a single sample per pixel.

Finally, the 'maxResourceSize' field specifies the maximum size, in bytes, that a resource of this format might be.
This should not be confused with the maximum extent, which reports the maximum size in each of the dimensions that might be supported.
For example, if an implementation reports that it supports images of 16,384 * 16,384 pixels * 2,048 layers with a format containing 128 bits per pixel, then creating an image of the maximum extent in every dimension would produce 8TiB image.
However, it might well support creating an 8 * 8 * 2,048 array or a 16,384 * 16,284 nonarray image, either of which would fit into a more moderate memory foot print. (???????)

5. Images
Images are more complex than buffers in that they are multidimensional; have specific layouts and format information; and can be used as the source and destination for complex operations such as filtering, blending, depth or stencil testing, and so on..
Images are created using the vkCreateImage() function, 
the prototype of which is
```
VkResult vkCreateImage(
	VkDevice										device,
	const VkImageCreateInfo*			pCreateInfo,
	const VkAllocationCallbacks*		pAllocator,
	VkImage*										pImage
);
```

The 'pCreateInfo' parameter is a pointer to an instance of the VkImageCreateInfo structure,
the definition of which is
```
typedef struct VkImageCreateInfo
{
	VkStructureType						sType;
	const void*								pNext;
	VkImageCreateFlags				flags;
	VkImageType							imageType;
	VkFormat									format;
	VkExtent3D								extent;
	uint32_t									mipLevels;
	uint32_t									arrayLayers;
	VkSampleCountFlagBits			samples;
	VkImageTiling							tiling;
	VkImageUsageFlags				usage;
	VkSharingMode						sharingMode;
	uint32_t									queueFamilyIndexCount;
	const uint32_t*							pQueueFamilyIndices;
	VkImageLayout						initialLayout;
} VkImageCreateInfo;
```

The command fields, 'sType' and 'pNext', appear at the top, as with most other Vulkan structures.
The 'sType' field should be set to VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO.

The 'flags' field of VkImageCreateInfo contains flags describing some of the properties of the image.
These are a selection of the VkImageCreateFlagBits enumeration.
```
1. VK_IMAGE_CREATE_SPARSE_BINDING_BIT &
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT &
	VK_IMAGE_CREATE_SPARTSE_ALIASED_BIT
	They are used for controlling sparse images, which are covered later in this chapter.

2. VKIMAGE_CREATE_MUTABLE_FORMAT
	If it is set, then you can create [views] of the image with a different format from the parent.
	Image views are essentially a special type of image that shares data and layout with its parent but can override prameters such as format.
	This allows data in the image to be interpreted in multiple ways at the same time.
	Using image views is a way to create two different aliases for the same data.
	Image view are covered later in this chapter.
	
3. VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
	If it is set, then the you will be able to create cube map views of it.
	Cube maps are covered later in this chapter.
```

The 'imageType' field of the VkImageCreateInfo structure specifies the type of image that you want to create.
The image type is essentially the dimensionality of the image and can be one of 
```
VK_IMAGE_TYPE_1D -> 1D image
VK_IMAGE_TYPE_2D -> 2D image
VK_IMAGE_TYPE_3D -> 3D image
, respectively
```

Images also have a format, which describes how texel data is stored in memory and how it is interpreted by Vulkan.
The format of the image is specified by the 'format' field of the VkImageCreateInfo structure and must be one of the image formats represented by a member of the VkFormatenumeration.
Vulkan supports a large number of formats-too many to list here.
We willl use some of the formats in the book examples and explain how they work at that time.
For the rest, refer to the Vulkan specification.

The 'extent' of an image is its size in texels.
This is specified in the 'extent' field of the VkImageCreateInfo structure.
This is an instance of the VkExtent3D structure, which has three members
```
typedef struct VkExtent3D
{
	uint32_t		width;
	uint32_t		height;
	uint32_t		depth;
} VkExtent3D;
```
These should be set to the width, hiehgt, and depth of the desired image, respectively.
For 1D images, height should be set to 1, and for 1D and 2D images, depth should be set to 1.
Rather than alias the next-higher dimension as an array count, Vulkan uses an explicit array size, which is set in arrayLayers.

The maximum size of an image that can be created is device-dependent.
To determine the largest image size, call vkGetPhysicalDeviceFeatures() and check the fields of the embedded VkPhysicalDeviceLimits structure.

Bellow description describe what field is for
```
maxImageDimension1D
	It contains the maximum supported width for 1D images.
	It is guaranteed to be at least 4,096 texels.

maxImageDimension2D 
	It contains the maximum side length for 2D images.
	It is guaranteed to be at least 4,096 texels.

maxImageDimension3D 
	It contains the maximum side length for 3D images.
	It is guaranteed to be at least 4,096 texels.

	(side length???)

maxImageArrayLayers
	It contains the maximum number of layers in an array image.
	It is guaranteed to be at least 256.

maxImageDimensionCube
	It contains the maximum side length for the cube.
	It is guaranteed to be at least 256.
```

If the image you want to create is smaller than these dimensions, then there's no need to check the device features.
Further, it's quite cmmon to find Vulkan implementations that support significantly higher limits.
It would be reasonable to make larger image sizes a hard requirement rather than trying to create fallback paths for lower-end devices. (???????????)

The number of mipmap levels to create in the image is specified in 'mipLevels'.
Mipmapping is the process of using a set of prefiltered images of successively lower resolution in order to improve image quality when undersampling the image.
The images that make up the various mipmap levels are arranged in a pyramid.

In a mipmapped texture, the base level is the lowest-numbered level (usually level zero) and has the resolution of the texture.
Each successive level is half the size of the level above it until halving the size of the image again in one of the dimensions would result in a single texel in that direction.
Sampling from mipmapped textures is covered in some detail in Chapter 6, "Shaders and Pipelines."

Likewise, the number of samples in the image is specified in 'samples'.
This field is somewhat unlike the others.
It must be a member of the VkSampleCountFlagBit enumeration, which is actually defined as bits to be used in a bitfield.
However, only power-of-two sample counts are currently defined in Vulkan, which means they're "1-hot" values, so single-bit enumerant values work just fine.

The 'tiling' field is a member of the VkImageTiling enumeration, which contains only VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL.
'Linear' tiling means that image data is laid out left to right, top to bottom, such that if you map the underlying memory and write it with the CPU, it would form a linear image.
Meanwhile, 'Optimal' tiling is an opaque representation used by Vulkan to lay data out in memory to improve efficiency of the memory subsystem on the device.
This is generally what you should choose unless you plan to map and manipulate the image with the CPU.
Optimal tiling will likely perform significantly better than linear tiling in most operations, and linear tiling might not be supported at all for some operations or formats, depending on the Vulkan implementation.

The 'usage' field is a bitfield describing where the image will be used.
This is similar to the 'usage' field in the VkBufferCreateInfo structure.
The 'usage' field here is made up of members of the VkImageUsageFlags enumeration, the member of which are as follows:
```
1. VK_IMAGE_USAGE_TRANSFER_SRC_BIT &
	VK_IMAGE_USAGE_TRANSFER_DST_BIT
	They mean that the image will be the source or destination of transfer commands, respectively.
	Transfer commands operating on images are covered in Chapter 4, "Moving Data."

2. VK_IMAGE_USAGE_SAMPLED_BIT
	It means that the image can be sampled from in a shader.

3. VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
	It means that the image can be used for general-purpose storage, including write from a shader.

4. VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
	It means that the image can be bound as a color attachment and drawn into using graphics operations.
	Framebuffers and their attachments are covered in Chapter 7, "Graphics Pipelines"

5. VK_IMAGE_USAGE_TRASIENT_ATTACHMENT_BIT
	It means that the image can be used as a transient attachment, which is a special kind of image used to store intermediate results of a graphics operation.
	Transient attachments are covered in Chapter 13, "Multipass Rendering".

6. VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
	It means that the image can be used as a special input during graphics rendering.
	Input images differ from regular sampled or storage images in that only fragment shaders can read from them and only at their own pixel location.
	Input attachments are also covered in detail in Chapter 13, "Multipass Rendering."
```

The 'sharingMode' is identical in function to the similarly named field in the VkBufferCreateInfo structure described in "Buffers" eariler in this chapter.
```
VK_SHARING_MODE_EXCLUSIVE
	Then image will be used with only a single queue family at a time.
	
VK_SHARING_MODE_CONCURRENT
	Then the image may be accessed by multiple queues concurrently.
```
Likewise, 'queueFamilyIndexCount' and 'pQueueFamilyIndices' provide similar function and are used when 'sharingMode' is VK_SHARING_MODE_CONCURRENT.

Finally, images have a 'layout', which specifies in part how it will be used at any given moment.
The 'initialLayout' field determines which layout the image will be created in.
The available layouts are the members of the VkImageLayout enumeration, which are
```
1. VK_IMAGE_LAYOUT_UNDEFINED
	The state of the image is undefined.
	The image must be moved into  one of the other layouts before it can be used almost for anything.

2. VK_IMAGE_LAYOUT_GENERAL
	This is the "lowest common denominator" layout and is used where no other layout matches the intended use case.
	Images in VK_IMAGE_LAYOUT_GENERAL can be used almost anywhere in the pipeline.

3. VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
	The image is going to be rendered into using a graphics pipeline.

4. VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
	The image is going to be used as a depth of stencil buffer as part of a graphics pipeline.

5. VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL
	The image is going to be used for depth testing but will not be written to by the graphics pipeline.
	In this special state, the image can also be read from in shaders.

6. VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
	The image will be bound for reading by shaders.
	This layout is typically used when an image is going to be used as a texture.

7. VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
	The image is the source of copy operations.

8. VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
	The image is the destination of copy operations.

9. VK_IMAGE_LAYOUT_PREINITIALIZED
	The image contains data placed there by an external actor, such as by mapping the underlying memory and writing into it from the host. (????)

10. VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
	The image is used as the source for presentation, which is the act of showing it to the user.
```

Images can be moved from layout to layout, and we will cover the various layouts as we introduce the topics related to them.
However, images must intially be created in either the VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED layer.
VK_IMAGE_LAYOUT_PREINITIALIZED should be used only when you have data in memory that you will bind to the image resource immediately.
VK_IMAGE_LAYOUT_UNDEFINED should be used when you plan to move the resource to another layout before use.
Images can be moved out of VK_IMAGE_LAYOUT_UNDEFINED layout at little or no cost at any time.

The mechanism for changing the layout of an image is known as a pipeline barrier, or simply a barrier.
A barrier not only serves as a means to change the layout of a resource but can also synchronize access to that resource by different stages in the Vulkan pipeline and even by different queues running concurrently on the same device. (??)
As such, a pipeline barrier is fairly complex and quite difficult to get right.
Pipeline barriers are discussed in some detail in Chapter 4, "Moving Data," and are further explained in the sections of the book where they are relevant.

Bellow codes show a simple example of creating an image resource.

```

	static const VkImageCreateInfo imageCreateInfo =
	{
		VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,		
		nullptr,																				
		0,																						
		VK_IMAGE_TYPE_2D,
		VK_FORMAT_R8G8B8A8_UNORM,								
		{1024, 1024, 1},																
		10,																					
		1,																						
		VK_SAMPLE_COUNT_1_BIT	,										
		VK_IMAGE_TILING_OPTIMAL,										
		VK_IMAGE_USAGE_SAMPLED_BIT,							
		VK_SHARING_MODE_EXCLUSIVE,								
		0,																						
		nullptr,																				
		VK_IMAGE_LAYOUT_UNDEFINED								
	};

	VkImage image = VK_NULL_HANDLE;

	vkCreateImage(device , &imageCreateInfo, &myAllocator, &image);

	vkDestroyImage(device, image, &myAllocator);
```

The image created by the code is a 1,024 * 1,024 texel 2D image with a single sample, in VK_FORMAT_R8G8B8A8_UNORM format and optimal tiling.
The code creates it in the undefined layout, which means that we can move it to another layout later to place data into it.
The image is to be used as a texture in one of our shaders, so we set the VK_IMAGE_USAGE_SAMPLED_BIT usage flag.
In our simple applications, we use only a single queue, so we set the sharing mode to exlusive.

6. Linear Images
VK_IMAGE_TILING_OPTIMAL mode represents an opaque, implementation-defined layout that is intended to improve the efficiency of the memory subsystem of the device for read and write operations on the image.
However, VK_IMAGE_TILING_LINEAR is a transparent layout of the data that is inteded to be intuitive.
Pixels in the image are laid out left to right, top to bottom.

In addition to the image's width, height, depth, and pixel format, a few pieces of information are needed to enable host access to the underlying image data.
```
the row pitch of the image, which is the distance in bytes between the start of each row of the image; 
the array pitch, which is the distance between array layers; 
the depth pitch, which is the distance between depth slices.
```
Of course, the array pitch and depth pitch apply only to array or 3D images, respectively, and the row pitch applies only to 2D or 3D images.

An image is normally made up of several subresources. 
Some formats have more than one aspect, which is a component of the image such as the depth or stencil component in a depth-stencil image.
Mipmap levels and array layers are also considered to be separate subresources.
The layout of each subresource within an image may be different and therefore has different layout information.
This information can be queried by calling vkGetImageSubresourceLayout(), the prototype of which is
```
void vkGetImageSubresourceLayout(
	VkDevice										device,
	VkImage										image,
	const VkImageSubresource*		pSubresource,
	VkSubresourceLayout*				pLayout
);
```

The device that owns the image that is being queried is passed in 'device', and the image being queried is passed in 'image'.
A description of the subresource is passed through an instance of the VkImageSubresource structure, a pointer to which is passed in the 'pSubresource' parameter.
The definition of it is
```
typedef struct VkImageSubresource
{
	VkImageAspectFlags			aspectMask;
	uint32_t								mipLevel;
	uint32_t								arrayLayer;
} VkImageSubresource;
```

The aspect or aspects of the image that you want to query the layout of is specified in aspectMask.
```
1. VK_IMAGE_ASPECT_COLOR_BIT
	For color images

2. VK_IMAGE_ASPECT_DEPTH_BIT
	For depth images

3. VK_IMAGE_ASPECT_STENCIL_BIT
	For stencil images

i. VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT
	For depth-stencil images
```

The mipmap level for which the parameters are to be returned in specified in 'mipLevel', and the array layer is specified in 'arrayLayer'.
You should normally set 'arrayLayer' to zero, as the parameters of the image are not expected to change across layers.

When vkGetImageSubresourceLayout() returns, it will have written the layout parameters of the subresource into the VkSubresourceLayout structure pointed to by pLayout.
The definition of which is 
```
typedef struct VkSubresourceLayout {
	VkDeviceSize			offset;
	VkDeviceSize			size;
	VkDeviceSize			rowpitch;
	VkDeviceSize			arrayPitch;
	VkDeviceSize			depthPitch;
} VkSubresourceLayout;
```

The size of the memory region consumed by the requested subresource is returned in 'size', and the offset within the resource where the subresource begins is returned in 'offset'.
The 'rowPitch', 'arrayPitch', 'depthPitch' fields contain the row, array layer, and depth slice pitches, respectively.
The unit of these fields is always bytes. regardless of the pixel format of the images.
Pixels within a row are always tightly packed.
Figure 2.2 illustrates how these parameters represent memory layout of an image.
In the figure, the valid image data is represented by the grey grid, and padding around the image is shown as blank space.

Given the memory layout of an image in 'LINEAR' tiling mode, it is possible to trivially compute the memory address for a single texel within the image.
Loading image data into a 'LINEAR' tiled image is then simply a case of loading scanlines from the image into memory at the right location.
For many texel formats and image dimensions, it is highly likely that the image's rows are tightly packed in memory - that is, the 'rowPitch' field of the VkSubresourceLayout structure is equal to the subresource's width.
In this case, many image-loading libraries will be able to load the image directly into the mapped memory of the image.

7. Nonlinear Encoding
You may have noticed that some of the Vulkan image formats include SRGB in their names.
This refers to sRGB color encoding, which is a nonlinear encoding that uses a gamma curve approximating that of CRT.
Although CRTs are all but obsolete now, sRGB encoding is till in widespread use for texture and image data.

Because the amount of light energy produced by a CRT is not linear with the amount of electrical energy used to produce the electron beam that excites the phosphor, an inverse mapping must be applied to color signals to make a linear rise in numberic value produce a linear increase in light output.
The amount of light output by a CRT is approximately
```
L out = V in ^ y
```

The standard value of y in NTSC television systems (common in North America, parts of South America, and parts of Asia) is 2.2.
Meanwhile, the standard value of y in SECAM and PAL systems (common in Europe, Africa, Austraila, and other regions of Asia) is 2.8.

The sRGB curve attempts to compensate for this by applying gamma correction to linear data in memory.
The standard sRGB transfer function is not a pure gamma curve but is made up of a short linear section followed by a curved, gamma-corrected section.
The function applied to data to go from linear to sRGB space is
```
if (cl >= 1.0)
{
	cs = 1.0;
}
else if (cl <= 0.0)
{
	cs = 0.0;
}
else if (cl < 0.0031308)
{
	cs = 12.92 * cl;
}
else
{
	cs = 1.055 * pow(cl, 0.41666) - 0.55;
}
```

To go from sRGB space to linear space, the following transform is made:
```
if (cs >= 1.0)
{
	cl = 1.0;
}
else if (cs <= 0.0)
{
	cl = 0.0;
}
else if (cs <= 0.04045)
{
	cl = cs / 12.92;
}
else 
{
	cl = pow((cs + 0.0555) / 1.055), 2.4);
}
```

In both code snippets, 'cs' is the sRGB color space value, and 'cl' is the linear value.
Figure 2.3 shows a side-by-side comparison of a simple y = 2.2 curve and the standard sRGB transfer function.
As you can see in the figure, the curves for sRGB correction (shown on the top) and a simple power curve (shown on the bottom) are almost identical.
While Vulkan implementations are expected to implement sRGB using the official definition, if you need to perform the transformation manually in your shaders, you may be able to get away with a simple power function without accumulating too much error.

When rendering to an image in sRGB format, linear values produced by your shaders are transformed to sRGB encoding before being written into the image.
When reading from an image in sRGB format, texels are transformed from sRGB format back to linear space before being returned to your shader.

Blending and interpolation always occurs in linear space such that data read from a framebuffer is first transformed from sRGB to linear space and then blended with the source data in linear space, and the final result is transformed back to sRGB encoding before being written into the framebuffer.
 -> which means calculation occurs in linear space and result in sRGB space.

Rendering in sRGB space provides more precision in darker colors and can result in less banding artifacts and richer colors.
However, for best image quality, including high-dynamic-range rendering it's best to choose a floating-point color format and render in a linear space, converting to sRGB as late as possible before display.

8. Compressed Image Formats
Since image resources are the largest consumers of device memory, Vulkan provides the capability for images to be compressed.
Image compression provides two significant benefits to an application:
```
1. It reduces the total amount of memory consumed by image resources used by the application.

2. It reduces the total memory bandwidth consumed while accessing those resources.
```

All currently defined compressed image formats in Vulkan are what are known as 'block compressed' formats.
Texels within an image are compressed in small square or rectangular blocks that can be decompressed independently of all others.
All formats are lossy, and the compression ratio is not competitive with formats such as JPEG or even PNG.
However, decompression is fast and cheap to implement in hardware, and random access to texels is relatively straightforward.

Support for various compressed image formats is optional, but all Vulkan implementations are required to support at least one family of formats.
You can determine which family of compressed formats is supported by checking various fields of the device's VkPhysicalDeviceFeatures structure as returned from a call to vkGetPhysicalDeviceProperties().

If 'textureCompressionBC' is VK_TRUE, then the device supports the 'block compressed' formats, also known as BC formats. 
The BC family includes
```
BC1: Made up of the 
VK_FORMAT_BC1_RGB_UNORM_BLOCK, 
VK_FORMAT_BC1_RGB_SRGB_BLOCK, 
VK_FORMAT_BC1_RGBA_UNORM_BLOCK, and
VK_FORMAT_BC1_RGBA_SRGB_BLOCK formats, BC1 encodes images in blocks 4X4 texels, with each block represented as a 64-bit quantity.

BC2: Consisting of 
VK_FORMAT_BC2_UNORM_BLOCK and
VK_FORMAT_BC2_SRGB_BLOCK, BC2 encodes images in blocks of 4X4 texels, which each block represented as a 128-bit quantity.
BC2 images always have an alpha channel. 
The encoding for the RGB channels is the same as with BC1 RGB formats, and the alpha is stored as 4bits per texel in a second 64-bit field before the BC1 encoded RGB data.

BC3: The
VK_FORMAT_BC3_UNORM_BLOCK and
VK_FORMAT_BC3_SRGB_BLOCK formats make up the BC3 family, again encoding texels in 4X4 blocks, with each block consuming 128 bits of storage.
The first 64-bit quantity stores compressed alpha values, allowing coherent alpha data to be stored with higher precision than BC2.
The second 64-bit quantity stores compressed color data in a similar form to BC1.

BC4: 
VK_FORMAT_BC4_UNORM_BLOCK and 
VK_FORMAT_BC4_SRGB_BLOCK represent single-channel formats, again encoded as 4X4 blocks of texels, with each block consuming 64 bits of storage.
The encoding of the single-channel data is essentially the same as that of the alpha channel of a BC3 image.

BC5: Made up of 
VK_FORMAT_BC5_UNORM_BLOCK and
VK_FORMAT_BC5_SRGB_BLOCK, the BC5 family is a two-channel format, with each 4X4 block essentially consisting of two BC4 blocks back-to-back.

BC6: The
VK_FORMAT_BC6H_SFLOAT_BLOCK and
VK_FORMAT_BC6H_UFLOAT_BLOCK formats are signed and unsigned floating-point compressed formats, respectively.
Each 4X4 block of RGB texels is stored in 128 bits of data.

BC7:
VK_FORMAT_BC7_UNORM_BLOCK and
VK_FORMAT_BC7_SRGB_BLOCK are four channel formats with each 4X4 block of RGBA texel data stored in a 128-bit component.
```

If the textureCompressionETC2 member of VkPhysicalDeviceFeatures is VK_TRUE, then the device supports the ETC formats, including ETC2 and EAC.
The following formats are included in this family:
```
1. VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK and
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
	Unsigned formats where 4X4 blocks of RGB texels are packed into 64 bits of compressed data.

2. VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK and
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
	Unsigned formats where 4x4 blocks of RGB texels plus a one-bit alpha value per texel are packed into 64 bits of compressed data.

3. VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK and
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
	Each 4x4 block of texels is represented as a 128-bit quantity. Each texel has 4 channels.

4. VK_FORMAT_EAC_R11_UNORM_BLOCK and
	VK_FORMAT_EAC_R11_SNORM_BLOCK:
	Unsigned and signed single-channel formats with each 4x4 block of texels represented as a 64-bit quantity.

5. VK_FORMAT_EAC_R11G11_UNORM_BLOCK and
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK:
	Unsigned and signed two-channel formats with each 4x4 block of texels represented as a 64-bit quantity.
```

The final family is the ASTC family.
If the textureCompressionASTC_LDR member of VkPhysicalDeviceFeatures is VK_TRUE, then the device supports the ASTC formats.
You may have noticed that for all of the formats in the BC andETC families, the block size is fixed at 4x4 texels, but depending on format, the texel format and number of bits used to store the compressed data vary.
ASTC is different here in that the number of bits per block is always 128, and all ASTC formats have four channels.
However, the block size in texels can vary.
The following block sizes are supported:
```
4x4, 5x4, 5x5, 6x5, 6x6, 8x5, 8x6, 8x8, 10x5, 10x6, 10x8, 10x10, 12x10, and 12x12.
```

The format of the token name for ASTC formats is formulated as 
VK_FORMAT_ASTC_{N}X{M}_{encoding}_BLOCK,
where {n} and {m} represent the width and height of the block, and {encoding} is either UNORM or SRGB, depending on whether the data is linear or encoded as sRGB nonlinear.
For example, VK_FORMAT_ASTC_8x6_SRGB_BLOCK is an RGBA ASTC compressed format with 8x6 blocks and sRGB encoded data.

For all formats including SRGB, only the R, G, and B channels use nonlinear encoding.
The A channel is always stored with linear encoding.

9. Resource Views
Buffers and images are the two primary types of resources supported in Vulkan.
In addition to creating these two resource types, you can create 'views' of existing resources in order to partition them, reinterpret their content, or use them for multiple purposes.
Views of buffers, which represent a subrange of a buffer object, are known as 'buffer views', and view of images, which can alias formats or represent a subresource of another image, are known as 'image views'.

Before a view of a buffer or image can be created, you need to bind memory to the parent object.

10. Buffer Views
A buffer view is used to interpret the data in a buffer with a specific format.
Because the raw data in the buffer is then treated as a sequence of texels, this is also known as a texel buffer view.
A texel buffer view can be accessed directly in shaders, and Vulkan will automatically convert the texels in the buffer into the format expected by the shader.
One example use for this functionality is to directly fetch the properties of vertices in a vertex shader by reading from a texel buffer rather than using a vertex buffer.
While this is more restrictive, it does allow random access to the data in the buffer.

To create a buffer view, call vkCreateBufferView(), 
the prototype of which is
```
VkResult vkCreateBufferView(
	VkDevice											device,
	const VkBufferViewCreateInfo*		pCreateInfo,
	const VkAllocationCallbacks*			pAllocator,
	VkBufferView*									pView
);
```

The device that is to create the new view is passed in 'device'. 
This should be the same device that created the buffer of which you are creating a view.
The remaining parameters of the new view are passed through a pointer to an instance of the VkBufferViewCreateInfo structure, the definition of which is
```
typedef struct VkBufferViewCreateInfo
{
	VkStructureType						sType;
	const void*								pNext;
	VkBufferViewCreateFlags		flags;
	VkBuffer									buffer;
	VkFormat									format;
	VkDeviceSize							offset;
	VkDeviceSize							range;
} VkBufferViewCreateInfo;
```

The 'sType' field of VkBufferViewCreateInfo should be set to VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO.
The 'pNext' should be set to nullptr.
The 'flags' field is reserved and should be set to 0.
The parent buffer is specified in 'buffer'.
The new view will be a "window" into the parent buffer starting at 'offset' bytes and extending for 'range' bytes.
When bound as a texel buffer, the data in this buffer is interpreted as a sequence of texels with the format as specified in 'format'.

The maximum number of texels that can be stored in a texel buffer is determined by inspecting the 'maxTexelBufferElements' field of the device's VkPhysicalDeviceLimits structure, which can be retreived by calling vkGetPhysicalDeviceProperties().
If the buffer is to be used as a texel buffer, then 'range' divided by the size of a texel in 'format' must be less than or equal to this limit.
'maxTexelBufferElements' is guaranteed to be at least 65,536, so if the view you're creating contains fewer texels, there's no need to query this limit.

The parent buffer must have been created with the
VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT flags in the 'usage' field of the VkBufferCreateInfo used to create the buffer.
The specified format must support the
VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT, or
VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT as reported by vkGetPhysicalDeviceFormatProperties().

On success, vkCreateBufferView() places the handle to the newly created buffer view in the variable pointed to by 'pView'.
If 'pAllocator' is not nullptr, then the allocation callbacks specified in the VkAllocationCallbacks structure it points to are used to allocate any host memory required by the new object.

10. Image Views
In many cases, the image resource cannot be used directly, as more information about it is needed than is included in the resource itself.
For example, you cannot use an image resource directly as an attachment to a framebuffer or bind an image into a descriptor set in order to sample from it in a shader.
To satisfy theses additional requirements, you must create an image view, which is essentially a collection of properties and a reference to a parent image resource.

An image view also allows all or part of an existing image to be seen as a different format.
The resulting new of the parent image must have the same dimensions as the parent, although a subset of the parent's array layers or mip levels may be included in the view.
The format of the parent and child images must also be 'compatible', which usually means that they have the same number of bits per pixel, even if the data formats are completely different and even if there are a different number of channels in the image.

To create a new view of an existing image, call vkCreateImageView(), the prototype of which is 
```
VkResult vkCreateImageView(
	VkDevice											device,
	const VkImageViewCreateInfo*		pCreateInfo,
	const VkAllocationCallbacks*			pAllocator,
	VkImageView*									pView
);
```

The device that will be used to create the new view and that should own the parent image is specified in 'device'.
The remaining paremeters used in the creation of the new view are passed through an instance of the VkImageViewCreateInfo structure, a pointer to which is passed in 'pCreateInfo'.
The definition of VkImageViewCreateInfo is
```
typedef struct VkImageViewCreateInfo
{
	VkStructureType							sType;
	const void*									pNext;
	VkImageViewCreateFlags			flags;
	VkImage										image;
	VkImageViewType						viewType;
	VkFormat										format;
	VkComponentMapping				components;
	VkImageSubresourceRange		subresourceRange;
} VkImageViewCreateInfo;
```

The 'sType' field of the structure should be set to VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO.
The 'pNext' should be set to nullptr.
The 'flags' field is reserved for future use and should be set to 0.

The parent image of which to create a new view is specified in 'image'.
The type of view to create is specified in 'viewType'.
The view type must be compatible with the parent's image type and is a member of the VkImageViewType enumertion, which is larger than the VkImageType enumeration used in creating the parent image.
The image view types are as follows:
```
1. VK_IMAGE_VIEW_TYPE_1D, 
	VK_IMAGE_VIEW_TYPE_2D, and
	VK_IMAGE_VIEW_TYPE_3D
	They are the "normal" 1D, 2D, and 3D image types.

2. VK_IMAGE_VIEW_TYPE_CUBE and
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
	They are cube map and cube map array images.

3. VK_IMAGE_VIEW_TYPE_1D_ARRAY and
	VK_IMAGE_VIEW_TYPE_2D_ARRAY
	They are 1D and 2D array images.
```

Note that all images are essentially considered array images, even if they only have one layer.
It is, however, possible to create nonarray views of parent images that refer to one of the layers of the image.

The format of the new view is specified in 'format'.
This must be a format that is compatible with that of the parent image.
In general, if two formats have the same number of bits per pixel, then they are considered compatible.
If either or both of the formats is block compressed image format, then one of two things must be true:
```
1. If both images have compressed formats, then the number of bits per block must match between those formats.

2. If only one image is compressed and the other is not, then bits per block in the compressed image must be the same as the number of bits per texel in the uncompressed image.
```

By creating an uncompressed view of a compressed image, you give access to the raw, compressed data, making it possible to do things like write compressed data from a shader into the image or interpret the compressed data directly in your application.
Ntoe that while all block-compressed formats encode blocks either as 64-bit or 128-bit quantities, there are no uncompressed, single-channel 64-bit or 128-bit image formats.
To alias a compressed image as an uncompressed format, you need to choose an uncompressed format with the same number of bits per texel and then aggregate the bits from the different image channels within your shader to extract the individual fields from the compressed data.

The component ordering in the view may be different from that in the parent.
This allows, for example, an RGBA view of a BGRA format image to be created.
This remapping is specified using an instance of VkComponentMapping, the definition of which is simply
```
typedef struct VkComponentMapping
{
	VkComponentSwizzle r;
	VkComponentSwizzle g;
	VkComponentSwizzle b;
	VkComponentSwizzle a;
} VkComponentMapping;
```

Each member of VkComponentMapping specifies the 'source' of data in the parent image that will be used to fill the resulting texel fetched from the child view.
They are members of the VkComponentSwizzle enumeration, the members of which are as follows:
```
1. VK_COMPONENT_SWIZZLE_R, 
	VK_COMPONENT_SWIZZLE_G,
	VK_COMPONENT_SWIZZLE_B, and
	VK_COMPONENT_SWIZZLE_A
	They indicate that the source data should be read from the R, G, B, or A channels of the parent image, respectively.

2. VK_COMPONENT_SWIZZLE_ZERO and 
	VK_COMPONENT_SWIZZLE_ONE
	They indicate that the data in the child image should be read as zero or one, respectively, regardless of the content of the parent image.

3. VK_COMPONENT_SWIZZLE_IDENTITY
	It indicates that the data in the child image should be read from the corresponding channel in the parent image.
	Note that the numeric value of VK_COMPONENT_SWIZZLE_IDENTITY is zero, so simply seetting the entire VkComponentMapping structure to zero will result in an identity mapping between child and parent images.
```

The child image can be a subset of the parent image.
This subset is specified using the embedded VkImageSubresourceRange structure in 'subresourceRange'.
The definition of which is
```
typedef struct VkImageSubresourceRange
{
	VkImageAspectFlags		aspectMask;
	uint32_t							baseMipLevel;
	uint32_t							levelCount;
	uint32_t							baseArrayLayer;
	uint32_t							layerCount;
} VkImageSubresourceRange;
```

The 'aspectMask' field is a bitfield made up from members of the VkImageAspectFlagBits enumeration specifying which aspects of the image are affected by the barrier.
Some image types have more than one logical part, even though the data itself might be interleaved or otherwise related.
An example of this is depth-stencil images, which have both a depth component and a stencil component.
Each of these two components may be viewable as a separate image in its own right, and these subimages are known as 'aspects'. 
The flags that can be included in 'aspectMask' are
```
1. VK_IMAGE_ASPECT_COLOR_BIT:
	The color part of an image.
	There is usually only a color aspect in color images.

2. VK_IMAGE_ASPECT_DEPTH_BIT:
	The depth aspect of a depth-stencil image.

3. VK_IMAGE_ASPECT_STENCIL_BIT:
	DThe stencil aspect of a depth-stencil image.

4. VK_IMAGE_ASPECT_METADATA_BIT:
	Any additional infromation associated with the image that might track its state and is used, for example, in various compression techniques.
```

When you create the new view of the parent image, that view can refer to only one aspect of the parent image.
Perhaps the most common use case of this is to create a depth- or stencil-only view of a combined depth-stencil format image.

To create a new image view that corresponds only to a subset of the parent's mip chain, use the 'baseMipLevel' and 'levelCount' to specify where in the mip chain the view begins and how many mip levels it will contain.
If the parent image does not have mipmaps, these fields should be set to zero and one, respectively.

Likewise, to create an image view of a subset of a parent's array layers, use the 'baseArrayLayer' and 'layerCount' fields to specify the starting layer and number of layers, respectively.
Again, if the parent image is not an array image, then 'baseArrayLayer' should be set to zero and 'layerCount' should be set to one.

11. Image Arrays
All images have a layer count, contained in the 'arrayLayers' field of their VkImageCreateInfo structure.

Images can be aggregated into arrays, and each lelement of an array image is known as a layer.
Array images allow images to be rouped into single objects, and sampling from multiple layers of the same array image is often more performant than sampling from several loose array objects.
Because all Vulkan images have a 'layerCount' field, they are all technically array images.
However, in practive, we only refer to images with a 'layerCount' greater than 1 as an array image.

When views are created of images, the view is explicitly marked as either an array or a nonarray.
A nonarray view implicitly has only one layer whereas an array view has multiple layers.
Sampling from a nonarray view may perform better than sampling from a single layer of an array image, simply because the device needs to perform fewer indirections and parameter lookups.

A 1D array texture is conceptually different from a 2D texture, and a 2D array texture is different from a 3D texture.
The primary difference is that linear filtering can be performed in the y direction of a 2D texture and in the z direction in a 3D texture, whereas filtering cannot be performed across multiple layers in an array image. (????????)
Notice that there is no 3D array image view type included in VkImageViewType, and most Vulkan implementations will not alow you to create a 3D image with an 'arrayLayers' field greater than 1.

In addition to image arrays, a 'cube map' is a special type of image that allows groups of siz layers of an array image to be interpreted as the sides of a cube.
Imagine standing in the center of a cube-shaped room.
These faces are often notated as the -X, +X, -Y, +Y, -Z, and +Z faces.
These are the six faces of a cube map, and a group of six consecutive array layers can be interpreted in that order.

A cube map is sampled using a 3D coordinate. 
This coordinate is interpreted as a vector pointing from the center of the cube map outward, and the point sampled in the cube-map is the point where the vector meets the cube.

Figure 2.4 shows this pictorially. 
As you can see in the figure, the cube map is constructed from a selection of six consecutive elements from the parent texture.
To create a cube-map view, first create a 2D array image with at least six faces.
The 'imageType' field of the VkImageCreateInfo structure should be set to VK_IMAGE_TYPE_2D and the 'arrayLayers' field should be at least 6.
Note that the number of layers in the parent array does not have to be a multiple of 6, but it has to be at least 6.

The 'flags' field of the parent image's VkImageCreateInfo structure must have the VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set, and the image must be square (because the faces of a cube are square).

Next we create a view of the 2D array parent, but rather than creating a normal 2D (array) view of the image, we create a cube-map view.
To do this, set the 'viewType' field of the VkImageViewCreateInfo structure used to creat the view to VK_IMAGE_VIEW_TYPE_CUBE.
In the embedded 'subresourceRange' field, the 'baseArrayLayer' and 'layerCount' fields are used to determine where in the array the cube map begins.
To create a single cube, 'layerCount' should be set to 6.

The first element of the array (at the index specified in the 'baseArrayLayer' field) becomes the -X face, and the next five layers become the +X, -Y, +Y, -Z, and +Z faces, in that order.

Cube maps can also form arrays of their own. This is simply a concatenation of an integer multiple of six faces, with each group of six forming a separate cube.
To create a cube-map array image, set the 'viewType' field of VkImageViewCreateInfo to VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, and set the 'layerCount' for the array divided by 6.
The number of layers in the parent image must be at least as many layers as are referenced by the cube-map view.

When data is placed in a cube map or cube-map array image, it is treated identically to an array image.
Each array layer is laid out consecutively, and commands such as vkCmdCopyBufferToImage() (which is covered in Chapter 4, "Moving Data") can be used to write into the image.
The image can be bound as a color attachment and rendered to.
Using layered rendering, you can even write to multiple faces of a cube map in a single drawing command.

12. Destroying Resources
When you are done with buffers, images, and other resources, it is important to destroy them cleanly.
Before destroying a resource, you must make sure that it is not in use and that no work is pending that might access it.
Once you are certain that this is the case, you can destroy the resource by calling the appropriate destruction function.
To destroy a buffer resource, call vkDestroyBuffer(), the prototype of which is
```
void vkDestroyBuffer(
	VkDevice											device,
	VkBuffer											buffer,
	const VkAllocationCallbacks*			pAllocator
);
```

Note that destroying a buffer object for which other views exist will also invalidate those views.
The view objects themselves must still be destroyed explicitly, but it is not legal to access a view of a buffer that has been destroyed.
To destroy a buffer view, call vkDestroyBufferView(), the prototype of which is
```
void vkDestroyBufferView(
	VkDevice										device,
	VkBufferView								bufferView,
	const VkAllocationCallbacks*		pAllocator
);
```

Destruction of images is almost identical to that of buffers.
To destroy an image object, call vkDestroyImage(), the prototype of which is
```
void vkDestroyImage (
	VkDevice										device,
	VkImage										image,
	const VkAllocationCallbacks*		pAllocator
);
```

As with buffers, destroying an image invalidates all views of that image.
It is not legal to access a view of an image that has already beend destroyed.
The only thing you can do with such views is to destroy them.
Destroying an image view is accomplished by calling vkDestroyImageView(), the prototype of which is

```
void vkDestroyImageView (
	VkDevice										device,
	VkImageView								imageView,
	const VkAllocationCallbacks*		pAllocator);
```

13. DEVICE MEMORY MANAGEMENT
When the Vulkan device operates on data, the data must be stored in 'device memory'.
This is memory that is accessible to the device.
In a Vulkan system there are four classes of memory.
Some systems may have only a subset of these, and some may only have two.
Given a host (the processor upon which your application is running) and a device (the processor that executes your Vulkan commands), there could be separate memory physically attached to each.
In addition, some regions of the physical memory attached to each processor might be accessible to the other processor or processors in the system. (????)

In some cases, the visible region of shared memory might be relatively small, and in other cases, there may actually be only one physical piece of memory, which is shared between the host and the device.
Figure 2.5 demonstrates the memory map of a host and device with physically separate memories.

Any memory that is accessible to the device is known as 'device memory', even if that memory is physically attached to the host.
In this case, it is 'host local device memory'. 
This is distinct from host memory, which might also be known as system memory, which is regular memory allocated with a function such as 'malloc' or 'new'.
Device memory may also be accessible to the host through a mapping.

A typical discrete GPU as found on an add-in card plugged into a PIC-Express slot will have an amount of dedicated memory physically attached to its circuit board.
Some part of this memory may be accessible only to the device, and some part of the memory may be accessible to the host through some form of window.
In addition, the GPU will have access to some or all of the host's system memory.
All of these pools of memory will appear as a heap to the host, and memory will be mapped into those heaps via the various types of memory.

On the other hand, a typical embedded GPU-such as those found in embedded systems, mobile devices, or even laptop processors-may share memory controller and subsystem with the host processor.
In this case, it is likely that access to main system memory is coherent and the device will expose fewer heaps-perhaps only one.
This is considered a 'unified memory architecture'.

14. Allocating Device Memory
A device memory allocation is represented as a VkDeviceMemory object that is created using the vkAllocateMemory() function, the prototype of which is
```
VkResult vkAllocateMemory(
	VkDevice										device,
	const VkMemoryAllocateInfo*		pAllocateInfo,
	const VkAllocationCallbacks*		pAllocator,
	VkDeviceMemory*						pMemory
);
```

'AllocateInfo' describes the new device memory object which, if the allocation is successful, will be placed in the variable pointed to by 'pMemory'.
'pAllocateInfo' points to an instance of the VkMemoryAllocateInfo structure, the definition of which is
```
typedef struct VkMemoryAllocateInfo
{
	VkStructureType		sType;
	const void*				pNext;
	VkDeviceSize			allocationSize;
	uint32_t					memoryTypeIndex;
} VkMemoryAllocateInfo;
```

This is a simple structure containing only the size and the memory type to be used for the allocation.
'sType' should be set to VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO.
'pNext' should be set to nullptr unless an extension is in use that requires more information about the allocation.
The size of the allocation is passed in 'allocationSize' and is measured in bytes.
The memory type, passed in 'memoryTypeIndex', is an index into the memory type array returned from a call to vkGetPhysicalDeviceMemoryProperties(), as described in "Physical Device Memory" in Chapter 1, "Overview of Vulkan".

Once you have allocated device memory, it can be used to back resources such as buffers and images.
Vulkan may use device memory for other purposes, such as other types of device objects, internal allocations and data structures, scratch storage, and so on.
These allocations are managed by the Vulkan driver, as the requirements may vary quite widely between implementations.

When you are done with a memory allocation, you need to free it.
To do this, call vkFreeMemory(), the prototype of which is
```
void vkFreeMemory(
	VkDevice										device,
	VkDeviceMemory						memory,
	const VkAllocationCallbacks*		pAllocator
);
```

vkFreeMemory() takes the memory object directly in 'memory'.
It is your responsibility to ensure that there is no work queued up to a device that might use the memory object before you free it.
Vulkan will not track this for you.
If a device attempts to access memory after it's been freed, the results can be unpredictable and can easily crash your application.

Further, access to 'memory' must be externally synchronized.
Attempting to free device memory with a call to vkFreeMemory() while another command is executing in another thread will produce undefined behavior and possibly crash your application.

On some platforms, there may be an upper bound to the total number of memory allocations that can exist within a single process.
If you try to create more allocations than this limit, allocation could fail.
This limit can be determined by calling vkGetPhysicalDeviceProperties() and inspecting the 'maxMemoryAllocationCount' field of the returned VkPhysicalDeviceLimits structure.
The limit is guaranteed to be at least 4,096 allocations, though some platforms may report a much higher limit.
Although this may seems low, the intention is that you create a small number of large allocations and then suballocate from them to place many resources in the same allocation.
There is no upper limit to the total number of resources can be created, memory allowing.

Normally, when you allocate memory from a heap, that memory is permanently assigned to the returned VkDeviceMemory object until that object is destroyed by calling vkFreeMemory().
In some cases, you (or even the Vulkan implementation) may not know exactly how much memory is required for certain operations, or indeed whether any memory is required at all.

In particular, this is often the case for images that are used for intermediate storage of data during rendering.
When the image is created, if the VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT is included in the VkImageCreateInfo structure,
then Vulkan knows that the data in the image will live for a short time, and therefore, it's possible that it may never need to be written out to device memory.

In this case, you can ask Vulkan to be 'lazy' with its allocation of the memory object to defer true allocation until Vulkan can determine that the physical storage for data is really needed.
To do this, choose a memory type with the VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT set.
Choosing an otherwise-appropriate memory type that does not have this bit set will still work correctly but will always allocate the memory up front, even if it never ends up being used. (????? Is not this good? Since allocating memory cost a lot timely, I learned that allocating memory at the loading or specific time)

If you want to know whether a memory allocation is physically backed and how much backing gas actually been allocated for a memory object, call vkGetDeviceMemoryCommitment(),
the prototype of which is 
```
void vkGetDeviceMemoryCommitment (
	VkDevice					device,
	VkDeviceMemory	memory,
	VkDeviceSize*			pCommittedMemoryInBytes
);
```

The device that owns the memory allocation is passed in 'device' and the memory allocation to query is passed in 'memory'.
'pCommittedMemoryInBytes' is a pointer to a variable that will be overwritten with the number of bytes actually allocated for the memory object.
That commitment will always come from the heap associated with the memory type used to allocate the memory object.

For memory objects allocated with memory types that do not include VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT, or if the memory object ended up fully committed,
	vkGetDeviceMemoryCommitment() will always return the full size of the memory object.
The commitment returned from vkGetDeviceMemoryCommitment() is informational at best.
In many cases, the information could be out of data, and there's not much you can do with the information anyway.

14. Host Access to Device Memory
As discussed eariler in this chapter, device memory is divided into multiple regions.
Pure device memory is accessible only to the device.
However, there are regions of memory  that are accessible to both the host and the device.
The host is the processor upon which your application is running, and it is possible to ask Vulkan to give you a pointer to memory allocated from host-accessible regions.
This is known as 'mapping' memory.

To map device memory into the host's address space, the memory object to be mapped must have been allocated from a heap that has the 
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT flag set in its heap properties.
Assuming that this is the case, mapping the memory to obtain a pointer usable by the host is achieved by calling vkMapMemory(), the prototype of which is
```
VkResult vkMapMemory(
	VkDevice						device,
	VkDeviceMemory		memory,
	VkDeviceSize				offset,
	VkDeviceSize				size,
	VkMemoryMapFlags	flags,
	void**							ppData
);
```

The handle to the memory object being mapped is passed in memory.
Access to the memory object must be externally synchronized.
To map a reange of a memory object, specify the starting offset in 'offset' and the size of the region in 'size'.
If you want to map the entire memory object, set offset to 0 and 'size' to VK_WHOLE_SIZE.
Setting 'offset' to a nonzero value and 'size' to VK_WHOLE_SIZE will map the memory object starting from 'offset' to the end.
'offset' and 'size' are both specified in bytes.
You should not attempt to map a region of the memory object that extends beyond its bounds.

The 'flags' parameter is reserved for future use and should be set to zero.

If vkMapMemory() is successful, a pointer to the mapped region is writeen into the variable pointed to by 'ppData'.
This pointer can then be cast to the appropriate type in your application and dereferenced to directly read and write the device memory.
Vulkan guarantees that pointers returned from vkMapMemory() are aligned to an integer multiple of the device's minimum memory mapping alignment when 'offset' is subtracted from them.

This value is reported in the 'minMemoryMapAlignment' field of the VkPhysicalDeviceLimits structure returned from a call to vkGetPhysicalDeviceProperties().
It is guaranteed to be at least 64 bytes but could be any higher power of two.
On some CPU architectures, much higher performance can be achieved by using memory load and store instructions that assume aligned addresses.
'minMemoryMapAlignment' will often match a cache line size or the natural alignment of the machine's widest register, for example, to facilitate this.
Some host CPU instructions will fault if passed an unaligned address.
Therefore, you can check 'minMemoryMapAlignment' once and decide 
	whether to use optimized functions that assume aligned addressing or fallback functions that can handle unaligned addresses at the expense of performance.
		 This line looks important.


When you're done with the pointer to the mapped memory range, it can be unmapped by calling vkUnmapMemory(), the prototype of which is
```
vkUnmapMemory(
	VkDevice					device,
	VkDeviceMemory	memory
);
```

The device that owns the memory object is passed in 'device', and the memory object to be unmapped is passed in 'memory'.
As with vkMapMemory(), access to the memory object must be externally synchronized.

It's not possible to map the same memory object more than once at the same time.
That is, you cannot call vkMapMemory() on the same memory object with different memory ranges, whether they overlap or not, without unmapping the memory object in between.
The range isnot needed when unmapping the object becasue Vulkan knows the range that was mapped.

As soon as the memory object is unmapped, any pointer received from a call to vkMapMemory() is invalid and should not be used.
Also, if you map the same range of the same memory object over and over, you should not assume that the pointer you get back will be the same.

When device memory is mapped into host address space, there are effectively two clients of that memory, which may both perform writes into it.
There is likely to be a cache hierarchy on both the host and the device sides of the mapping, and those caches may or may not be coherent.
In order to ensure that both the host and the device see a coherent view of data written by the other client, 
	it is necessary to force Vulkan to flush caches that mightcontain data written by the host but not yet made visible to the device 
	or to invalidate a host cache that might hold stale data that has been overwritten by the device.

Each memory type advertised by the device has a number of properties, one of which might be VK_MEMORY_PROPERTY_HOST_COHERENT_BIT.
If this is the case, and a mapping is made from a region with this property set, then Vulkan will take care of coherency between caches.
In some cases, the caches are automatically coherent because they are either shared between host and device or have some form of coherency protocal to keep them in sync.
In other cases, a Vulkan driver might be able to infer when caches need to be flushed or invalidated and then perform these operations behind the scenes.

If VK_MEMORY_PROPERTY_HOST_COHERENT_BIT is not set in the memory properties of a mapped memory region,
	then it is your responsibility to explicitly flush or invalidate caches that might be affected by the mapping.
To flush host caches that might contain pending writes, call vkFlushMappedMemoryRanges(), the prototype of which is
```
VkResult vkFlushMappedMemoryRanges(
	VkDevice												device,
	uint32_t												memoryRangeCount,
	const VkMappedMemoryRange*			pMemoryRanges
);
```

The number of ranges to flush is specified in 'memoryRangeCount', and the details of each range are passed in an instance of the VkMappedMemoryRange structure.
A pointer to an array of 'memoryRangeCount' of these structures is passed through the 'pMemoryRanges' is
```
typedef VkMappedMemoryRange
{
	VkStructureType			sType;
	const void*					pNext;
	VkDeviceMemory		memory;
	VkDeviceSize				offset;
	VkDeviceSize				size;
} VkMappedMemoryRange;
```

The 'sType' field of VkMappedMemoryRange should be set to VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE.
The 'pNext' should be set to nullptr.
Each memory range refers to a mapped memory object specified in the 'memory' field and a mapped range within that object, specified by 'offset' and 'size'.
You don't have to flush the entire mapped region of the memory object, so 'offset' and 'size' do not need to match the parameters used in vkMapMemory().
Also if the memory object is not mapped, or if 'offset' and 'size' specify a region of the object that is not mapped, then the flush command has no effect.
To just flush any existing mapping on a memory object, set 'offset' to zero and 'size' to VK_WHOLE_SIZE.

A flush is necessary if the host has written to a mapped memory region and needs the device to see the effect of those writes.
However, if the device writes to a mapped memory region and you need the host to see the effect of the device's writes, 
	you need to invalidate any caches on the host that might now hold stale data.
To do this, call vkInvalidateMappedMemoryRange(), the prototype of which is
```
VkResult vkInvalidateMappedMemoryRange(
	VkDevice											device,
	uint32_t											memoryRangeCount,
	const VkMappedMemoryRange*		pMemoryRanges
);
```

The number of regions is speccified in 'memoryRangeCount', and a pointer to an array of 'memoryRangeCount' VkMappedMemoryRange structures is passed in 'pMemoryRanges'.
The fields of the VkMappedMemoryRangeStructures are interpreted exactly as they are in vkFlushMappedMemoryRanges(),	
	except that the operation performed is an invalidation rather than a flush.

vkFlushMappedMemoryRanges() and vkInvalidateMappedMemoryRanges() affect only caches and coherency of access by the 'host' and have no effect on the device.
Regardless of whether a memory mapping is coherent or not, access by the device to memory that has been mapped must still be synchronized using 'barriers', 
	which will be discussed layer in this chapter.

15. Binding Memory to Resources
Before a resource such as a buffer or image can be used by Vulkan to store data, memory must be bound to it.
Before memory is bound to a resource, you should determine what 'type' of memory and how much of it the resource requires.
There is a different function for buffers and for textures.
They are vkGetBufferMemoryRequirements() and vkGetImageMemoryRequirements(), and their prototypes are
```
void vkGetBufferMemoryRequirements(
	VkDevice									device,
	VkBuffer									buffer,
	VkMemoryRequirements*		pMemoryRequirements
);

void vkGetImageMemoryRequirements(
	VkDevice									device,
	VkImage									image,
	VkMemoryRequirements*		pMemoryRequirements
);
```

The only difference between these two functions is that vkGetBufferMemoryRequirements() takes a handle to a buffer object and 
	vkGetImageMemoryRequirements() takes a handle to an image object.
Both functions return the memory requirements for the resource in an instance of the VkMemoryRequirements structure, 
	the address of which is passed in the 'pMemoryRequirements' parameter.
The definition of which is
```
typedef struct VkMemoryRequirements
{
	VkDeviceSize			size;
	VkDeviceSize			alignment;
	uint32_t					memoryTypeBits;
} VkMemoryRequirements;
```

The amount of memory needed by the resource is placed in the 'size' field.
The alignment requirements of the object are placed in the 'alignment' field.
When you bind memory to the object (which we will get to in a moment), 
	you need to ensure that the offset from the start of the memory object meets the alignment requirements of the resource and 
	that there is sufficient space in the memory object to store the object.

The 'memoryTypeBits' field is populated with all the memory types that the resource can be bound to.
One bit is turned on, starting from the least significant bit, for each type that can be used with the resource.
If you have no particular requirements for the memory, 
	simply find the lowest-set bit and use its index to choose the memory type, 
	which is then used as the 'memoryTypeIndex' field in the allocation info passed to a call to vkAllocateMemory().
If you do have particular requirements or preferences for the memory - if you want to be able to map the memory or prefer that it be host local, for example - look for a type that includes those bits and is supported by the resource. (????????)

Below codes show an example of an appropriate algorithm for choosing the memory type for an image resource.
```

// When I have particular requirements or preferences for the memory,
uint32_t MyVulkan::ChooseHeapFromFlags(const VkMemoryRequirements& memoryRequirements, VkMemoryPropertyFlags requiredFlags, VkMemoryPropertyFlags preferredFlags)
{
	VkPhysicalDeviceMemoryProperties deviceMemoryProperties;
	vkGetPhysicalDeviceMemoryProperties(physicalDevices.front(), &deviceMemoryProperties);

	uint32_t selectedType = ~0u;
	uint32_t memoryType;
		
	for (memoryType = 0; memoryType < VK_MAX_MEMORY_TYPES; memoryType++)
	{
		if (memoryRequirements.memoryTypeBits & (1<<memoryType))
		{
			const VkMemoryType& type = deviceMemoryProperties.memoryTypes[memoryType];

			// If it exactly matches my preffered properties, grab it.
			if ((type.propertyFlags & preferredFlags) == preferredFlags)
			{
				selectedType = memoryType;
				break;
			}
		}
	}

	if (selectedType != ~0u)
	{
		for (memoryType = 0; memoryType < 32; memoryType++)
		{
			if (memoryRequirements.memoryTypeBits & (1 << memoryType))
			{
				const VkMemoryType& type = deviceMemoryProperties.memoryTypes[memoryType];

				// If it has all my required properties, it'll do.
				if ((type.propertyFlags & requiredFlags) == requiredFlags)
				{
					selectedType = memoryType;
					break;
				}
			}
		}
	}

	return selectedType;
}

```

The algorithm shown in upper code chooses a memory type given the memory requirements for an object, a set of hard requirements, and a set of preferred requirements.
First, it iterates through the device's supported memory types and checks each for the set of preferred flags.
If there is a memory type that contains all of the flags that the caller prefers, then it immediately returns that memory type.
If none of the device's memory types exactly matches the preferred flags, then it iterates again, this time returning the first memory type that meets all of the requirements.

Once you have chosen the memory type for the resource, you can bind a piece of a memory object to that resource by calling either vkBindBufferMemory() for buffer objects
	or vkBindImageMemory() for image objects.
Their prototypes are
```
VkResult vkBindBufferMemory(
	VkDevice						device,
	VkBuffer						buffer,
	VkDeviceMemory		memory,
	VkDeviceSize				memoryOffset
);

VkResult vkBindImageMemory(
	VkDevice						device,
	VkImage						image,
	VkDeviceMemory		memory,
	VkDeviceSize				memoryOffset
);
```

Again, 'device' must own both the resource and the memory object, whose handle is passed in 'memory'.
This is the handle of a memory allocation created through a call to vkAllocateMemory().

Access to 'buffer' and 'image' from vkBindBufferMemory() and vkBindImageMemory(), respectively, must be externally synchronized.
Once memory has been bound to a resource object, the memory binding cannot be changed again.
If two threads attempt to execute vkBindBufferMemory() or vkBindImageMemory() concurrently,
	then which thread's binding takes effect and which one is invalid is subject to a race condition.
Even resolving the race condition would not produce a legal command sequence, so this should be avoided.

The 'memoryOffset' parameter specifies 'where' in the memory object the resource will live.
The amount of memory consumed by the object is determined from the size of the object's requirements, 
	as discovered with a call to vkGetBufferMemoryRequirements() or vkGetImageMemoryRequirements().

It is very strongly recommended that rather than simply creating a new memory allocation for each resource,
	you create a pool of a small number of relatively large memory allocations and place multiple resources in each one at different offsets.
It is possible for two resources to overlap in memory.
In general, aliasing data like this is not well defined, but if you can be sure that two resources are not used at the same time, this can be a good way to reduce the memory requirements of your application.

An example of a device memory allocator is included with the book's source code. (which does not included though)

16. Sparse Resources 
Sparse resources are a special type of resource that can be partially backed by memory and can have their memory backing changed after they have been created and even used in the application.
A sparse resource must still be bound to memory before it can be used, although that binding can be changed.
Additionally, an image or buffer can support sparse residency, which allows parts of the image to not be backed by memory at all.

The create a sparse image, set the VK_IMAGE_CREATE_SPARSE_BINDING_BIT in the 'flags' field of the VkImageCreateInfo structure used to create the image.
Likewise, to create a sparse buffer, set the VK_BUFFER_CREATE_SPARSE_BINDING_BIT in the 'flags' field of the VkBufferCreateInfo structure used to create the buffer.

If an image was created with the VK_IMAGE_CREATE_SPARSE_BINDING_BIT bit set, 
	your application should call vkGetImageSparseMemoryRequirements() to determine the additional requirements that the image needs.
The prototype of vkGetImageSparseMemoryRequirements() is
```
void vkGetImageSparseMemoryRequirements(
	VkDevice														device,
	VkImage														image,
	uint32_t*														pSparseMemoryRequirementCount,
	VkSparseImageMemoryRequirements*		pSparseMemoryRequirements
);
```

The 'pSparseMemoryRequirements' parameter points to an array of VkSparseImageMemoryRequirements structures that will be filled with the requirements of the image.

It is also work similarly with vkGetPhysicalDeviceQueueFamilyProperties().
First call with nullptr in 'pSparseMemoryRequirements' to get 'pSparseMemoryRequirementCount' and then call the function again with dynamically allocated array with the variable.

The definition of VkSparseImageMemoryRequirements is
```
typedef struct VkSparseImageMemoryRequirements
{
	VkSparseImageFormatProperties		formatProperties;
	uint32_t												imageMipTailFirstLod;
	VkDeviceSize										imageMipTailSize;
	VkDeviceSize										imageMipTailOffset;
	VkDeviceSize										imageMipTailStride;
} VkSparseImageMemoryRequirements;
```

The first field of VkSparseImageMemoryRequirements is an instance of the VkSparseImageFormatProperties structure that provides general information about how the image is laid out in memory with respect to binding.
```
typedef struct VkSparseImageFormatProperties {
	VkImageAspectFlags					aspectMask;
	VkExtent3D									imageGranularity;
	VkSparseImageFormatFlags		flags;
} VkSparseImageFormatProperties;
```

The 'aspectMask' field of VkSparseImageFormatProperties is a bitfield indicating the image aspects to which the properties apply.
This will generally be all of the aspects in the image.
For color image, it will be VK_IMAGE_ASPECT_COLOR_BIT, and for depth, stencil, and depth-stencil images, it will be either or both of VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT.

When memory is bound to a sparse image, it is bound in blocks rather than to the whole resource at once.
Memory has to be bound in implementation-specific sized blocks, and the 'imageGranularity' field of VkSparseImageFormatProperties contains this size.

Finally, the 'flags' field contains some additional flags describing further behavior of the image. The flags that may be included are
```
1. VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT:
	If this bit is set and the image is an array, then the mip tail shares a binding shared by all array layers.
	If the bit is not set, then each array layer has its own mip tail that can be bound to memory independently of others.

2. VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT:
	If this bit is set, it is an indicator that the mip tail begins with the first level that is not a multiple of the image's binding granularity.
	If the bit is not set, then the tail begins at the first level that is smaller than the image's binding granularity.

3. VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT:
	If this bit is set, then the image's format does support sparse binding, but not with the standard block sizes.
	The values reported in 'imageGranularity' are still correct for the image but do not necessarily match the standard block for the format.
```

Unless VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT is set in 'flags', then the values in 'imageGranularity' match a set of standard block sizes for the format.
The size, in texels, of various formats is shown in Table 2.1.

The remaining fields of VkSparseImageMemoryRequirements describe how the format used by the image bahaves in the mip tail.
The mip tail is the region of the mipmap chain beginning from the first level that cannot be sparsely bound to memory.
This is typically the first level that is smaller than the size of the format's granularity.
As memory must be bound to sparse resources in units of the granularity, the mip tail presents an all-or-nothing binding opportunity.
Once any level of the mipmap's tail is bound to memory, all levels within the tail become bound.

The mip tail begins at the level reported in the 'imageMipTailFirstLod' field of VkSparseImageMemoryRequirements.
The size of the tail, in bytes, is contained in 'imageMipTailSize', and it begins at 'imageMipTailOffset bytes into the image's memory binding region.
If the image does not have a single mip tail binding for all array layers (as indicated by the presence of VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT in the 'aspectMask' field of VkSparseImageFormatProperties), 
	then 'imageMipTailStride' is the distance, in bytes, between the start of the memory binding for each mip tail level.

The properties of a specific format can also determined by calling vkGetPhysicalDeviceSparseImageFormatProperties(), which, given a specific format, 
	will return a VkSparseImageFormatProperties describing that format's sparse image requirements without the need to create an image and query it.
The prototype of vkGetPhysicalDeviceSparseImageFormatProperties() is
```
void vkGetPhysicalDeviceSparseImageFormatProperties(
	VkPhysicalDevice								physicalDevice,
	VkFormat												format,
	VkImageType										type,
	VkSampleCountFlagBits						samples,
	VkImageUsageFlags							usage,
	VkImageTiling										tiling,
	uint32_t*												pPropertyCount,
	VkSparseImageFormatProperties*		pProperties
);
```

The format of the image is passed in 'format'.
The type of image(VK_IMAGE_TYPE_1D, VK_IMAGE_TYPE_2D, or VK_IMAGE_TYPE_3D) is passed in 'type'.
If multisampling is required, the number of samples (represented as one of the members of the VkSampleCountFlagBits enumeration) is passed in 'samples'.

The intended usage for the image is passed in 'usage'.
This should be a bitfield containing the flags specifying how an image with this format will be used.
Be aware that sparse images may not be supported at all under certain use cases, so it's best to set this field conservatively and accurately rather than just turning on every bit and hoping for the best.
Finally, the tiling mode to be used for the image is specified in 'tiling'.
Again, standard block sizes may be supported only in certain tiling modes.
For example, it's very unlikely that an implementation would support standard (or even reasonable) block sizes when 'LINEAR' tiling is used.

Just as with vkGetPhyiscalDeviceImageFormatProperties(), vkGetPhyiscalDeviceSparseImageFormatProperties() can return an array of properties.
Thus, 'pPropertyCount' and 'pProperties' work as what we did.
Call this function twice.
First time to overwrite to 'pPropertyCount', and second time to get properties with dynamically allocated array.

Because the memory binding used to back sparse images can be changed, 
	even after the image is in use, the update to the binding properties of the image is pipelined along with that work.
Unlike vkBindImageMemory() and vkBindBufferMemory(), which are operations likely carried out by the host, 
	memory is bound to a sparse resource using an operation on the queue, allowing the device to execute them.
The command to bind memory to a sparse resource is vkQueueBindSparse(), the prototype of which is
```
VkResult vkQueueBindSparse(
	VkQueue									queue,
	uint32_t									bindInfoCount,
	const VkBindSparseInfo*			pBindInfo,
	VkFence									fence
);
```

The queue that will execute the binding operation is specified in 'queue'.
Several binding operations can be performed by a single call to vkQueueBindSparse().
The number of operations to perform is passed in 'bindInfoCount', and 'pBindInfo' is a pointer to an array of 'bindInfoCount' VkBindSparseInfo structures, each describing one of the bindings.
The definition of VkBindSparseInfo is
```
typedef struct VkBindSparseInfo {
	VkStructureType															sType;
	const void*																	pNext;
	uint32_t																		waitSemaphoreCount;
	const VkSemaphore*													pWaitSemaphores;
	uint32_t																		bufferBindCount;
	const VkSparseBufferMemoryBindInfo*						pBufferBinds;
	uint32_t																		imageOpaqueBindCount;
	const VkSparseImageOpaqueMemoryBindInfo*			pImageOpaqueBinds;
	uint32_t																		imageBindCount;
	const VkSparseImageMemoryBindInfo*						pImageBinds;
	uint32_t																		signalSemaphoreCount;
	const VkSemaphore*													pSignalSemaphores;
} VkBindSparseInfo;
```

The act of binding memory to sparse resources is actually pipelined with other work performed by the device.
As you read in Chapter 1, "Overview of Vulkan", work is performed by submitting it to queues.
The binding is then performed along with the execution of commands submitted to the same queue.
Because vkQueueBindSparse() behaves a lot like a command submission, VkBindSparseInfo contains many fields related to synchronization.

The 'sType' field of VkBindSparseInfo should be set to VK_STRUCTURE_TYPE_BIND_SPARSE_INFO.
The 'pNext' should be set to nullptr.
As with VkSubmitInfo, 
	each sparse binding operation can optionally wait for one or more semaphores to be signaled before performing the operation and can signal one or more semaphores when it is done.
This allows updates to the sparse resource's bindings to be synchronized with other work performed by the device.

The number of semaphores to wait on is specified in 'waitSemaphoreCount', and the number of semaphores to signal is specified in 'signalSemaphoreCount'.
The 'pWaitSemaphores' field is a pointer to an array of 'waitSemaphoreCount' semaphore handles to wait on,
	and 'pSignalSemaphores' is a pointer to an array of 'signalSemaphoreCount' samaphores to signal.
Semaphores are covered in some detail in Chapter 11, "Synchronization".

Each binding operation can include updates to buffers and images.
The number of buffer binding updates is specified in 'bufferBindCount' and 'pBufferBinds' is a pointer to an array of 'bufferBindCount' VkSparseBufferMemoryBindInfo structures,
	each describing one of the buffer memory binding operations.
The definition of VkSparseBufferMemoryBindInfo is
```
typedef struct VkSparseBufferMemoryBindInfo
{
	VkBuffer										buffer;
	uint32_t										bindCount;
	const VkSparseMemoryBind*		pBinds;
};
```

Each instance of VkSparseBufferMemoryBindInfo contains the handle of the buffer to which memory will be bound.
A number of regions of memory can be bound to the buffer at different offsets.
The number of memory regions is specified in 'bindCount', and each binding is described by an instance of the VkSparseMemoryBind structure.
'pBinds' is a pointer to an array of 'bindCount' VkSparseMemoryBind structures.
The definition of which is
```
typedef struct VkSparseMemoryBind {
	VkDeviceSize								resourceOffset;
	VkDeviceSize								size;
	VkDeviceMemory						memory;
	VkDeviceSize								memoryOffset;

	VkSparseMemoryBindFlags		flags;
} VkSparseMemoryBind;
```

The size of the block of memory to bind to the resource is contained in 'size'.
The offsets of the block in the resource and in the memory object are contained in 'resourceOffset' and 'memoryOffset', respectively, and are both expressed in units of bytes.
The memory object that is the source of storage for the binding is specified in 'memory'.
When the binding is executed, the block of memory, 'size' bytes long and starting at 'memoryOffset' bytes into the memory object specified in 'memory', 
	will be bound into the buffer specified in the 'buffer' field of the VkSparseBufferMemoryBindInfo structure.

The 'flags' field contains additional flags that can be used to further control the binding.
No flags are used for buffer resources.
However, image resources use the same VkSparseMemoryBind structure to affect memory bindings directly to images.
This is known as an opaque image memory binding, and the opaque image memory bindings to be performed are also passed through the VkBindSparseInfo structure.
The 'pImageOpaqueBinds' member of VkBindSparseInfo points to an array of 'imageOpaqueBindCount' VkSparseImageOpaqueMemoryBindInfo structures defining the opaque memory bindings.
The definition of VkSparseImageOpaqueMemoryBindInfo is
```
typedef struct VkSparseImageOpaqueMemoryBindInfo
{
	VkImage											image;
	uint32_t											bindCount;
	const VkSparseMemoryBind*			pBinds;
} VkSparseImageOpaqueMemoryBindInfo;
```

Just as with VkSparseBufferMemoryBindInfo, 
	VkSparseImageOpaqueMemoryBindInfo contains a handle to the image to which to bind memory in 'image' and a pointer to an array of VkSparseMemoryBind structures in 'pBinds',
	Which is 'bindCount' elements long.
This is the same structure used for buffer memory bindings.
However, when this structure is used for images, 
	you can set the 'flags' field of each VkSparseMemoryBind structure to indlucde the VK_SPARSE_MEMORY_BIND_METADATA_BIT flag in order to explicitly bind memory to the metadata associated with the iamge.

When memory is bound opaquely to a sparse image, the blocks of memory have no defined correlation with texels in the image.
Rather, the backing store of the image is treated as a large, opaque region of memory with no information about how texels are laid out in it provided to the application.
However, so long as memory is bound to the entire image when it is used, results will still be well-defined and consistent.
This allows sparse images to be backed by multiple, smaller memory objects, potentially easing pool allocation strategies, for example.

To bind memory to an explicit region of an image, 
	you can perform a nonopaque image memory binding by passing one or more VkSparseImageMemoryBindInfo structures 
	through the VkBindSparseInfo structures passed to vkQueueBindSparse().
The definition of VkSparseImageMemoryBindInfo is
```
typedef struct VkSparseImageMemoryBindInfo
{
	VkImage													image;
	uint32_t													bindCount;
	const VkSparseImageMemoryBind*		pBinds;
} VkSparseImageMemoryBindInfo;
```

Again, the VkSparseImageMemoryBindInfo structure contains a handle to the image to which to bind memory in 'image'.
A count of the number of bindings to perform in 'bindCount'.
A pointer to an array of structures describing the bindings in 'pBinds'.
This time, however, 'pBinds' points to an array of 'bindCount' VkSparseImageMemoryBind structures, the definition of which is
```
typedef struct VkSparseImageMemoryBind
{
	VkImageSubresource					subresource;
	VkOffset3D									offset;
	VkExtent3D									extent;
	VkDeviceMemory						memory;
	VkDeviceSize								memoryOffset;
	VkSparseMemoryBindFlags		flags;
} VkSparseImageMemoryBind;
```

The VkSparseImageMemoryBind structure contains much more information about how the memory is to be bound to the image resource.
For each binding, the image subresource to which the memory is to be bound is specified in 'subresource', which is an instance of the VkImageSubresource, the definition of which is
```
typedef struct VkImageSubresource
{
	VkImageAspectFlags		aspectMask;
	uint32_t							mipLevel;
	uint32_t							arrayLayer;
} VkImageSubresource;
```

The VkImageSubresource allows you to specify the aspect of the image 
	(VK_IMAGE_ASPECT_COLOR_BIT, VK_IMAGE_ASPECT_DEPTH_BIT, or VK_IMAGE_ASPECT_STENCIL_BIT, for example) in 'aspectMask'
The mipmap level to which you want to bind memory in 'mipLevel', and the array layer where the memory should be bound in 'arrayLayer'.
For nonarray images, 'arrayLayer' should be set to zero.

Within the subresource, the 'offset' and 'extent' fields of the VkSparseImageMemoryBind structure define the offset and size of the region of texels to bind the image data to.
This must be aligned to the tile-size boundaries, 
	which are either the standard sizes as shown in Table 2.1 or the per-format block size that can be retrieved from vkGetPhysicalDeviceSparseImageFormatProperties().

Again, the memory object from which to bind memory is specified in 'memory', and the offset within the memory where the backing store resides is specified in 'memoryOffset'.
The same flags are available in the 'flags' field of VkSparseImageMemoryBind.

SUMMARY
This chapter introduced you to the different types of resources that are used by Vulkan.
It described how the memory used to back them is allocated and then associated with them.
It also explained how you can manage the application memory used by Vulkan through the use of a custom allocator.
You have seen how to move resources from state to state and how to synchronize access to them through pipeline barriers.
This enables efficient, parallel access to resources both from multiple stages of the Vulkan pipeline and from the host.