What You'll Learn in This Chapter
```
1. How to display the results of your program onscreen.
2. How to determine the display devices attached to the system.
3. How to change display modes and interface with a native window system.
```

Vulkan is primarily a graphics API in the sense that the majority of its functionality is dedicated to generating and processing images. 
Most Vulkan applications will be designed to show their results to the user. 
This is a process known as 'presentation'. 
However, because the variety of platforms upon which Vulkan runs is large, and because not all applications need to present their outputs to the user visually, 
	presentation is not a core part of the API but is handled by a set of extensions. 
This chapter discusses how to enable and use those extensions to get pictures on the screen.

1. Presentation Extension

Presentation in Vulkan is not part of the core API. 
In fact, a given implementation of Vulkan may not support presentation at all. 
The reasons for this are

```
1. Not all Vulkan applications need to present images to the user.
	Computecentric applications, for example, might produce nonvisual data or produce images that only need to be saved to disk rather than displayed in real time.

2. Presentation is generally handled by the operating system, window system, or other platform-specific library, which can vary quite a bit from platform to platform.
```

Due to this, presentation is handled by a set of extensions collectively known as the WSI extensions, or Window System Integration systems. 
Extensions in Vulkan must be enabled explicitly before they can be used, and the extension needed for each platform is slightly different, 
	as some of the functions take platform-specific parameters. 
Before you can perform any presentation-related operations, 
	therefore, you need to enable the appropriate presentation-related extensions using the mechanisms described in Chapter 1, ¡°Overview of Vulkan.¡±

Presentation in Vulkan is handled by a small suite of extensions. 
Functionality that is common to almost all platforms that support presenting graphical output to the user is supported by one extension, 
	and functionality that is specific to each platform is supported by a number of smaller, platform-specific extensions.

2. Presentation Surfaces

The object to which graphics data is rendered in order to be presented is known as a 'surface' and is represented by a VkSurfaceKHR handle. 
This special object is introduced by the 'VK_KHR_surface' extension. 
This extension adds general functionality for handling surface objects 
	but is customized on a per-platform basis to provide the platform-specific interfaces to associate a surface with a window. 
Interfaces are defined for Microsoft Windows, Mir and Wayland, X Windows via either the XCB or Xlib interface, and Android. 
Further platforms may be added in the future.

The prototypes and data types for the platform-specific parts of the extension are included in the main 'vulkan.h' header file 
	but are protected behind platform-specific preprocessor guards. 
The code for this book supports the Windows platform and the Linux platform via the Xlib and Xcb interfaces. 
To enable the code for these platforms, before including vulkan.h, 
	we must define one of the VK_USE_PLATFORM_WIN32_KHR, VK_USE_PLATFORM_XLIB_KHR, or VK_USE_PLATFORM_LIB_XCB_KHR defines. 
The build system for the book¡¯s source code does this for you using a compiler command-line option.

Vulkan is also supported on a wide range of other operating systems and device types. 
In particular, many of Vulkan¡¯s features are geared to mobile and embedded devices. 
For example, Vulkan is the API of choice on the Android platform, and in addition to the interfaces covered here, 
	the Android platform has full support through its own platform interfaces. 
Outside of initialization, though, using Vulkan on Android should be a fairly similar experience to using Vulkan on other platforms.

3. Presentation on Microsoft Windows

Before we can present, we need to determine whether any queues on a device support presentation operations. 
Presentation capability is a per-queue-family feature. 
On Windows platforms, call the vkGetPhysicalDeviceWin32PresentationSupportKHR() function to determine 
	whether a particular queue family supports presentation. 
Its prototype is
```
VkBool32 vkPhysicalDeviceWin32PresentationSupportKHR(
	VkPhysicalDevice		physicalDevice,
	uint32_t						queueFamilyIndex
);
```

The physical device being queried is passed in 'physicalDevice', and the queue family index is passed in 'queueFamilyIndex'. 
If at least one queue family supports presentation, then we can proceed to create presentable surfaces using the device. 
To create a surface, use the vkCreateWin32SurfaceKHR() function, whose prototype is
```
VkResult vkCreateWin32SurfaceKHR(
	VkInstance													instance,
	const VkWin32SurfaceCreateInfoKHR*		pCreateInfo,
	const VkAllocationCallbacks*						pAllocator,
	VkSurfaceKHR*											pSurface
);
```

This function associates a Windows native window handle with a new surface object and returns the object in the variable pointed to by 'pSurface'. 
Only a Vulkan instance is required, and its handle is passed into 'instance'. 
The information describing the new surface is passed through 'pCreateInfo', which is a pointer to an instance of the VkWin32SurfaceCreateInfoKHR structure, 
the definition of which is
```
typedef struct VkWin32SurfaceCreateInfoKHR
{
	VkStructure											sType;
	const void*											pNext;
	VkWin32SurfaceCreateFlagsKHR		flags;
	HINSTANCE										hinstance;
	HWND													hwnd;
} VkWin32SurfaceCreateInfoKHR;
```

The 'sType' field of VkWin32SurfaceCreateInfoKHR should be set to VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR.
The 'pNext' should be set to nullptr unless another extension in use extends the structure. 
The 'flags' field is reserved for future use and should be set to zero.

The 'hinstance' parameter should be set to the HINSTANCE of the application or module that was used to create the the native window. 
This is typically passed to the application in the first parameter of WinMain or can be obtained by calling the Win32 function GetModuleHandle with a null pointer. 
The 'hwnd' member is the handle to the native window with which to associate the Vulkan surface. 
This is the window in which the results of presentation to swap chains created for the surface will be displayed.

4. Presentation on Xlib-Based Platforms

The process for creating a surface on an Xlib-based system is similar. 
First, we need to determine whether the platform supports presentation to an Xlib surface on an X server. 
To do this, call vkGetPhysicalDeviceXlibPresentationSupportKHR(), whose prototype is
```
VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR(
	VkPhysicalDevice		physicalDevice,
	uint32_t						queueFamilyIndex,
	Display*						dpy,
	VisualID						visualID
);
```

For the physical device whose handle is specified in 'physicalDevice', and the queue family index specified in 'queueFamilyIndex'.
The vkGetPhysicalDeviceXlibPresentationSupportKHR() reports whether queues in that family support presentation to Xlib surfaces for a given X server. 
The connection to the X server is represented by the 'dpy' parameter. 
Presentation is supported on a per-format basis. 
In Xlib, formats are represented by visual IDs, and the visual ID for the intended format of the surface is passed in 'visualID'.

Assuming that at least one queue family on a device supports presentation to a format we'd like to use, 
	we can then create a surface for an Xlib window by calling the vkCreateXlibSurfaceKHR() function, the prototype of which is
```
VkResult vkCreateXlibSurfaceKHR(
	VkInstance												instance,
	const VkXlibSurfaceCreateInfoKHR*		pCreateInfo,
	const VkAllocationCallbacks*					pAllocator,
	VkSurfaceKHR*										pSurface
);
```

vkCreateXlibSurfaceKHR() creates a new surface associated with an Xlib window. 
The Vulkan instance should be passed in 'instance', and the remaining parameters controlling the creation of the surface are passed in 'pCreateInfo', 
	which is a pointer to an instance of the VkXlibSurfaceCreateInfoKHR structure, the definition of which is
```
typedef struct VkXlibSurfaceCreateInfoKHR
{
	VkStructureType								sType;
	const void*										pNext;
	VkXlibSurfaceCreateFlagsKHR		flags;
	Display*											dpy;
	Window											window;
} VkXlibSurfaceCreateInfoKHR;
```

The sType field of VkXlibSurfaceCreateInfoKHR should be set to VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR.
The 'pNext' should be set to nullptr. 
The 'flags' field is reserved and should be set to zero.

The 'dpy' field is the Xlib Display representing the connection to the X server.
The 'window' is the Xlib Window handle to the window with which the new surface will be associated.

If vkCreateXlibSurfaceKHR() requires any host memory, it will use the host memory allocator passed in 'pAllocator'. 
If 'pAllocator' is nullptr, then an internal allocator will be used.

If surface creation is successful, the resulting VkSurface handle is written into the variable pointed to by 'pSurface'.

5. Presentation with Xcb

Xcb is a slightly lower-level interface to the X protocol than is provided by Xlib and may be a better choice for applications that wish to achieve lower latency. 
As with Xlib and the other platforms, before creating objects for presentation on an Xcb system, 
	we need to determine whether any of the queues on a physical device support presentation. 
To do this, call vkGetPhysicalDeviceXcbPresentationSupportKHR(), the prototype of which is
```
VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR(
	VkPhysicalDevice		physicalDevice,
	uint32_t						queueFamilyIndex,
	xcb_connection_t*		connection,
	xcb_visualid_t				visual_id
);
```

The physical device being queried is passed in 'physicalDevice', and the index of the queue family is passed in 'queueFamilyIndex'. 
The connection to the X server is passed in 'connection'. 
Again, presentation capability is reported on a per-visual ID basis, and the visual ID being queried is passed in 'visual_id'.

Once you have determined that at least one queue family on the device supports presentation in the visual ID of your choice, 
	you can create a surface into which to render using vkCreateXcbSurfaceKHR(), the prototype of which is
```
VkResult vkCreateXcbSurfaceKHR(
	VkInstance												instance,
	const VkXcbSurfaceCreateInfoKHR*		pCreateInfo,
	const VkAllocationCallbacks*					pAllocator,
	VkSurfaceKHR*										pSurface
);
```

The Vulkan instance is passed in 'instance', and the remaining parameters controlling creation of the surface 
	are passed through an instance of the VkXcbSurfaceCreateInfoKHR structure pointed to by 'pCreateInfo'. 
The definition of VkXcbSurfaceCreateInfoKHR is
```
typedef struct VkXcbSurfaceCreateInfoKHR
{
	VkStructureType								sType;
	const void*										pNext;
	VkXcbSurfaceCreateFlagsKHR		flags;
	xcb_connection_t *							connection;
	xcb_window_t									window;
} VkXcbSurfaceCreateInfoKHR;
```

The 'sType' field for VkXcbSurfaceCreateInfoKHR should be set to VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO.
The 'pNext' should be set to nullptr. 
The 'flags' field is reserved and should be set to zero. 
The connection to the X server is passed in the 'connection' field, and the handle to the window is passed in 'window'.

If vkCreateXcbSurfaceKHR() is successful, it will write the handle to the new surface into the variable pointed to by 'pSurface'. 
If it needs any host memory to construct the handle and 'pAllocator' is not nullptr, then it will use your allocator to request that memory.

6. Swap Chains

Regardless of which platform you¡¯re running on, the resulting VkSurfaceKHR handle refers to Vulkan¡¯s view of a window. 
In order to actually present anything to that surface, it¡¯s necessary to create a special image that can be used to store the data in the window. 
On most platforms, this type of image is either owned by or tightly integrated with the window system, 
	so rather than creating a normal Vulkan image object, we use a second object called a swap chain to manage one or more image objects.

Swap-chain objects are used to ask the native window system to create one or more images that can be used to present into a Vulkan surface. 
This is exposed using the VK_KHR_swapchain extension. 
Each swap-chain object manages a set of images, usually in some form of ring buffer. 
The application can ask the swap chain for the next available image, render into it, and then hand the image back to the swap chain ready for display. 
By managing presentable images in a ring or queue, one image can be presented to the display while another is being drawn to by the application, 
	overlapping the operation of the window system and application.

To create a swap-chain object, call vkCreateSwapchainKHR(), the prototype of which is
```
VkResult vkCreateSwapchainKHR(
	VkDevice													device,
	const VkSwapchainCreateInfoKHR*		pCreateInfo,
	const VkAllocationCallbacks*					pAllocator,
	VkSwapchainKHR*									pSwapchain
);
```

The device with which the swap chain is to be associated is passed in 'device'. 
The resulting swap chain can be used with any of the queues on device that support presentation. 
The information about the swap chain is passed in an instance of the VkSwapchainCreateInfoKHR structure, the address of which is passed in 'pCreateInfo'. 
The definition of VkSwapchainCreateInfoKHR is
```
typedef struct VkSwapchainCreateInfoKHR
{
	VkStructureType								sType;
	const void*										pNext;
	VkSwapchainCreateFlagsKHR		flags;
	VkSurfaceKHR								surface;
	uint32_t											minImageCount;
	VkFormat											imageFormat;
	VkColorSpaceKHR							imageColorSpace;
	VkExtent2D										imageExtent;
	uint32_t											imageArrayLayers;
	VkImageUsageFlags						imageUsage;
	VkSharingMode								imageSharingMode;
	uint32_t											queueFamilyIndexCount;
	const uint32_t*									pQueueFamilyIndices;
	VkSurfaceTransformFlagBitsKHR	preTransform;
	VkCompositeAlphaFlagBitsKHR		compositeAlpha;
	VkPresentModeKHR						presentMode;
	VkBool32											clipped;
	VkSwapchainKHR							oldSwapchain;
} VkSwapchainCreateInfoKHR;
```

The 'sType' field for VkSwapchainCreateInfoKHR should be set to VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR.
The 'pNext' should be set to nullptr. 
The 'flags' field is reserved for use in future versions of the VK_KHR_swapchain extension and should be set to zero.

The surface to which the new swap chain will present is passed in 'surface'. 
This should be a surface created with one of the the platform-specific surface creation functions such as vkCreateWin32SurfaceKHR() or vkCreateXlibSurfaceKHR(). 
The number of images in the swap chain is passed in 'minImageCount'. 
For example, to enable double or triple buffering, set minImageCount to 2 or 3, respectively. 
Setting minImageCount to 1 represents a request to render to the front buffer or directly to the display. 
Some platforms don¡¯t support this (and may not even support double buffering). 
To determine the minimum and maximum number of images supported in a swap chain, 
	call vkGetPhysicalDeviceSurfaceCapabilitiesKHR(), which is discussed later in this section.

Note that setting 'minImageCount' to 2 means that you¡¯ll have a single front buffer and a single back buffer. 
After triggering presentation of a finished back buffer, you won¡¯t be able to begin rendering to the other buffer until the presentation has completed. 
For best performance, possibly at the price of some latency, you should set 'minImageCount' to at least 3 if the device supports it.

The format and color space of the presentable images is specified in 'imageFormat' and 'imageColorSpace'. 
The format must be a Vulkan format for which the device reports the presentation capability. 
The 'imageColorSpace' is a member of the VkColorSpaceKHR enumeration, the only member of which is VK_COLORSPACE_SRGB_NONLINEAR_KHR, 
	which means that the presentation engine can expect sRGB nonlinear data, if the imageFormat member indicates an sRGB format image.

The 'imageExtent' field specifies the dimensions of the images in the swap chain, in pixels.
The 'imageArrayLayers' field specifies the number of layers in each image. 
This can be used to render to a layered image and then present specific layers of it to the user. 
The 'imageUsage' field is a collection of the standard VkImageUsageFlags enumeration specifying how the images will be used (in addition to as present sources). 
For example, if you want to render to the image as a normal color attachment, you would include VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, 
	and if you want to write directly to it with a shader, you would include VK_IMAGE_USAGE_STORAGE_BIT.

The set of usages that are included in 'imageUsage' must be selected from the usages supported for swap-chain images. 
This is determined by calling vkGetPhysicalDeviceSurfaceCapabilitiesKHR(). (???????????????????????????)

 The 'preTransform' field specifies how the images should be transformed prior to presentation to the user. 
 This allows images to be rotated or flipped (or both) to accommodate things like portrait displays and rear-projection systems. 
 It is a bitwise combination of a selection of members of the VkSurfaceTransformFlagBitsKHR enumeration.

 The 'compositeAlpha' field controls how alpha composition is handled by the window system. 
 This is a member of the VkCompositeAlphaFlagBitsKHR enumeration. 
 If this is set to VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR, 
	then the alpha channel of the presentable image (if it exists) is ignored and treated as though it contains constant 1.0 values. 
Other values of compositeAlpha allow partially transparent images to be composited by the native window system.

The 'presentMode' field controls synchronization with the window system and the rate at which the images are presented to the surface. 
The available modes are
```
1. VK_PRESENT_MODE_IMMEDIATE_KHR:
	When presentation is scheduled, the image is presented to the user as soon as possible, without wating for any external events such as vertical blanking.
	This provides the highest possible frame rate but can introduce tearing or other artifacts.

2. VK_PRESENT_MODE_MAILBOX_KHR:
	When a new image is presented, it is marked as the pending image, 
		and at the next opportunity (probably after the next vertical refresh), the system will display it to the user. 
	If a new image is presented before this happens, that image will be shown, and the previously presented image will be discarded.

3. VK_PRESENT_MODE_FIFO_KHR:
	Images to be presented are stored in an internal queue and shown to the user in order. 
	A new image is taken from the queue at regular intervals (usually after each vertical refresh).

4. VK_PRESENT_MODE_FIFO_RELAXED_KHR:
	This mode behaves similarly to VK_PRESENT_MODE_FIFO_KHR, except that if the queue is empty and vertical refresh occurs, 
		the next image posted to the queue will be displayed immediately, similarly to VK_PRESENT_MODE_IMMEDIATE_KHR. 
	This allows an application running faster than the vertical refresh rate to avoid tearing while still going as fast as possible if it can¡¯t keep up in places.
```

As a general rule, if you want to run with vertical sync (vsync) on, select VK_PRESENT_MODE_FIFO_KHR, and 
	if you want to run as fast as possible, select VK_PRESENT_MODE_IMMEDIATE_KHR or VK_PRESENT_MODE_MAILBOX_KHR. 
VK_PRESENT_MODE_IMMEDIATE_KHR will show visible tearing in most cases but provides the lowest possible latency. 
VK_PRESENT_MODE_MAILBOX_KHR continues to flip at regular intervals, producing a maximum latency of one vertical refresh, but will not exhibit tearing.

The clipped member of VkSwapchainCreateInfoKHR is used to optimize cases where not all of the surface might be visible. 
For example, if the surface to which the images will be presented represents a window that might be covered or partially off the screen, 
	it may be possible to avoid rendering the parts of it that the user will never see. 
When clipped is VK_TRUE, Vulkan can eliminate those parts of the image from rendering operations. 
When clipped is VK_FALSE, Vulkan will render the entire image, regardless of whether it¡¯s visible or not.

Finally, the oldSwapchain field of VkSwapchainCreateInfoKHR may be used to pass an existing swap chain associated with the surface back to Vulkan for recycling. 
This is used when one swap chain is being replaced by another, such as when a window is resized and the swap chain needs to be reallocated with larger images.
(????? I did not fully get it yet.)

The parameters contained in the VkSwapchainCreateInfoKHR structure must all conform to the capabilities of the suface, 
	which you can determine by calling vkGetPhysicalDeviceSurfaceCapabilitiesKHR(), the prototype of which is
```
VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
	VkPhysicalDevice						physicalDevice,
	VkSurfaceKHR							surface,
	VkSurfaceCapabilitiesKHR*		pSurfaceCapabilities
);
```

The physical device that owns the surface is passed in 'physicalDevice', and the surface whose capabilies are being queried is passed in 'surface'. 
vkGetPhysicalDeviceSurfaceCapabilitiesKHR() then returns information about the surface in an instance of the VkSurfaceCapabilitiesKHR structure, 
	a pointer to which is provided through the 'pSurfaceCapabilities' parameter. 
The definition of VkSurfaceCapabilitiesKHR is
```
typedef struct VkSurfaceCapabilitiesKHR
{
	uint32_t											minImageCount;
	uint32_t											maxImageCount;
	VkExtent2D										currentExtent;
	VkExtent2D										minImageExtent;
	VkExtent2D										maxImageExtent;
	uint32_t											maxImageArrayLayers;
	VkSurfaceTransformFlagsKHR		supportedTransforms;
	VkSurfaceTransformFlagBitsKHR	currentTransform;
	VkCompositeAlphaFlagsKHR			supportedCompositeAlpha;
	VkImageUsageFlags						supportedUsageFlags;
} VkSurfaceCapabilities;
```

The number of images in the swap chain must fall between the 'minImageCount' and 'maxImageCount' parameters of the surface¡¯s capabilities. 
The current size of the surface at the time of the query is returned in 'currentExtent'. 
If the surface is resizable (such as a sizeable window on a desktop), 
	then the smallest and largest sizes that the surface can become are returned in 'minImageExtent' and 'maxImageExtent'. 
If the surface supports presentation from array images, the maximum number of layers in those images is returned in 'minArrayLayers'.

Some surfaces support performing transformations on images as they are presented. 
For example, an image might be flipped or rotated to accommodate presentation to displays or other devices that are at nonstandard angles. 
The set of supported transforms is returned in the 'supportedTransforms' field of VkSurfaceCapabilitiesKHR and 
	is a bitfield made up of a selection of members of the VkSurfaceTransformFlagBitsKHR enumeration. 
One of those bits is set in 'currentTransform', which contains the current transform applied when the query is made.

If the surface supports composition, then the supported composition modes are contained as a combination of flags from 
	the VkCompositeAlphaFlagBitsKHR enumeration in the supportedCompositeAlpha field.

Finally, the allowed usage for the images created through a swap chain on this surface is returned in 'supportedUsageFlags'.

Once you have a swap chain associated with a surface to which you want to present, you need to get handles to the images representing the items in the chain. (??)
To do this, call vkGetSwapchainImagesKHR(), the prototype of which is
```
VkResult vkGetSwapchainImagesKHR(
	VkDevice						device;
	VkSwapchainKHR		swapchain;
	uint32_t*						pSwapchainImageCount;
	VkImage*						pSwapchainImages;
);
```

The device that owns the swap chain should be passed in 'device', and the swap chain from which you are requesting images should be passed in 'swapchain'. 
'pSwapchainImageCount' points to a variable that will contain the number of images received. 
If 'pSwapchainImages' is nullptr, then the initial value of 'pSwapchainImageCount' will be ignored, 
	and the variable will instead be overwritten with the number of swap-chain images in the swap-chain object. 
If 'pSwapchainImages' is not nullptr, then it should be a pointer to an array of VkImage handles that will be filled with the images from the swap chain. 
The intial value of the variable pointed to by 'pSwapchainImageCount' is the length of the array, 
	and it will be overwritten with the number of images actually placed in the array.

Because when you create the swap chain, you get to specify only the 'minimum' number of images in the swap chain, not the exact number of images, 
	you need to use vkGetSwapchainImagesKHR() to determine how many images there really are in a swap chain, even if you just created it. 
Listing 5.1 demonstrates how to create a swap chain for an existing surface, query the number of images in it, and then query the actual image handles.

```
// Listing 5.1
void MyVulkan::CreateSwapChain()
{
	// First, we create the swap chain.
	VkSwapchainCreateInfoKHR swapchainCreateInfo =
	{
		VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,		// sType
		nullptr,																									// pNext
		0,																											// flags
		m_mainSurface,																					// surface
		2, 																										// minImageCount
		VK_FORMAT_R8G8B8A8_UNORM,													// imageFormat
		VK_COLORSPACE_SRGB_NONLINEAR_KHR,								// imageColorSpace
		{1024, 768},																							// imageExtent
		1,																											// imageArrayLayers
		VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,							// imageUsage
		VK_SHARING_MODE_EXCLUSIVE,													// imageSharingMode
		0,																											// queueFamilyIndexCount
		nullptr,																									// pQueueFamilyIndices
		VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,							// preTransform
		VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,								// compositeAlpha
		VK_PRESENT_MODE_FIFO_KHR,													// presentMode
		VK_TRUE,																							// clipped
		m_swapChain																						// oldSwapchain
	};

	VulkanHelper::VkCheck(
		vkCreateSwapchainKHR(
		logicalDevices.front(),
			&swapchainCreateInfo,
			&myAllocator,
			&m_swapChain
		),
		"vkCreateSwapchainKHR is failed!");

	// Next, we query the swap chain for the number of images it actaully contains.
	uint32_t swapchainImageCount = 0;
	VulkanHelper::VkCheck(
		vkGetSwapchainImagesKHR(
			logicalDevices.front(),
			m_swapChain,
			&swapchainImageCount,
			nullptr
		),
		"vkGetSwapchainImagesKHR is failed!"
	);
	// Now we resize our image array and retrieve the image handles from the swap chain.
	m_swapChainImages.resize(swapchainImageCount);
	VulkanHelper::VkCheck(
		vkGetSwapchainImagesKHR(
			logicalDevices.front(),
			m_swapChain,
			&swapchainImageCount,
			m_swapChainImages.data()
		),
		"vkGetSwapchainImagesKHR is failed!"
	);
}

```

Note that the code in Listing 5.1 contains many hard-coded values. 
In a more robust application, you should call vkGetPhysicalDeviceSurfaceCapabilitiesKHR() to determine the capabilities of the device 
	with respect to presenting the surface and the capabilities of the surface to support parameters 
	such as the transform mode, number of images in the swap chain, and so on.

In particular, the surface format chosen in the 'imageFormat' field of VkSwapchainCreateInfoKHR must be a format that is supported by the surface. 
To determine which formats can be used for swap chains associated with a surface, call vkGetPhysicalDeviceSurfaceFormatsKHR(), the prototype of which is
```
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormatsKHR(
	VkPhysicalDevice				physicalDevice,
	VkSurfaceKHR					surface,
	uint32_t*								pSurfaceFormatCount,
	VkSurfaceFormatKHR*		pSurfaceFormats
);
```

The physical device that you are querying is passed in 'physicalDevice', and the surface to which you want to present is passed in 'surface'. 
If 'pSurfaceFormats' is nullptr, then the variable pointed to by 'pSurfaceFormatCount' is overwritten with the number of formats supported by the surface. 
If 'pSurfaceFormats' is not nullptr, 
	then it is a pointer to an array of VkSurfaceFormatKHR structures large enough to receive the number of formats supported by the surface. 
In this case, the number of elements in the array is passed as the initial value of the variable pointed to by pSurfaceFormats, 
	and this is overwritten with the number of formats actually written to the array.

The definition of VkSurfaceFormatKHR is
```
typedef struct VkSurfaceFormatKHR
{
	VkFormat						format;
	VkColorSpaceKHR		colorSpace;
} VkSurfaceFormatKHR;
```

The 'format' field of VkSurfaceFormatKHR is the format of pixels in memory for the surface, and 'colorSpace' is the supported color space. 
At present, the only defined color space is VK_COLORSPACE_SRGB_NONLINEAR_KHR.

In some cases, devices will support presentation from almost any format. 
This is generally true of compositing systems that use the image you¡¯ve rendered to as an input to some further processing. 
However, other devices may support presenting from a very limited set of surface formats - perhaps only a single format for a particular surface. 
This is likely to be the case when you are presenting directly to a display device.
(?????????????????????????)

The images you get back from a call to vkGetSwapchainImagesKHR() aren¡¯t immediately usable. 
Before you can write any data into them, you need to acquire the next available image by using a call to vkAcquireNextImageKHR(). 
This function retrieves the index of the next image in the swap chain that your application should render to. Its prototype is
```
VkResult vkAcquireNextImageKHR(
	VkDevice						device,
	VkSwapchainKHR		swapchain,
	uint64_t						timeout,
	VkSemaphore				semaphore,
	VkFence						fence,
	uint32_t*						pImageIndex
);
```

The 'device' parameter is the device that owns the swap chain, and 'swapchain' is the handle to the swap chain to retrieve the next swap-chain image index from.

vkAcquireNextImageKHR() waits for a new image to become available before returning to the application. 
'timeout' specifies the time, in nanoseconds, that it will wait before returning. 
If the 'timeout' is exceeded, then vkAcquireNextImageKHR() will return VK_NOT_READY. 
By setting timeout to 0, you can implement nonblocking behavior whereby 
	vkAcquireNextImageKHR() will either return a new image immediately or return VK_NOT_READY to indicate that it would block if called with a nonzero timeout.

The index of the next image into which the application should render will be written into the variable pointed to by 'pImageIndex'. 
The presentation engine might still be reading data from the image, so in order to synchronize access to the image, 
	the 'semaphore' parameter can be used to pass the handle of a semaphore that will become signaled when the image can be rendered to, 
	or the 'fence' parameter can be used to pass the handle to a fence that will become signaled when it is safe to render to the image.

Semaphores and fences are two of the synchronization primitives supported by Vulkan. 
We will cover synchronization primitives in more detail in Chapter 11, ¡°Synchronization.¡±